// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSWPCommandArchives.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSWPCommandArchives_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSWPCommandArchives_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSSArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSDCommandArchives.pb.h"
#include "TSKArchives.pb.h"
#include "TSWPArchives.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSWPCommandArchives_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSWPCommandArchives_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSWPCommandArchives_2eproto;
namespace TSWP {
class AnchorAttachmentCommandArchive;
struct AnchorAttachmentCommandArchiveDefaultTypeInternal;
extern AnchorAttachmentCommandArchiveDefaultTypeInternal _AnchorAttachmentCommandArchive_default_instance_;
class ApplyHighlightTextCommandArchive;
struct ApplyHighlightTextCommandArchiveDefaultTypeInternal;
extern ApplyHighlightTextCommandArchiveDefaultTypeInternal _ApplyHighlightTextCommandArchive_default_instance_;
class ApplyPlaceholderTextCommandArchive;
struct ApplyPlaceholderTextCommandArchiveDefaultTypeInternal;
extern ApplyPlaceholderTextCommandArchiveDefaultTypeInternal _ApplyPlaceholderTextCommandArchive_default_instance_;
class ApplyRubyTextCommandArchive;
struct ApplyRubyTextCommandArchiveDefaultTypeInternal;
extern ApplyRubyTextCommandArchiveDefaultTypeInternal _ApplyRubyTextCommandArchive_default_instance_;
class CreateHyperlinkCommandArchive;
struct CreateHyperlinkCommandArchiveDefaultTypeInternal;
extern CreateHyperlinkCommandArchiveDefaultTypeInternal _CreateHyperlinkCommandArchive_default_instance_;
class DummyCommandArchive;
struct DummyCommandArchiveDefaultTypeInternal;
extern DummyCommandArchiveDefaultTypeInternal _DummyCommandArchive_default_instance_;
class FormatTextCommandArchive;
struct FormatTextCommandArchiveDefaultTypeInternal;
extern FormatTextCommandArchiveDefaultTypeInternal _FormatTextCommandArchive_default_instance_;
class InsertAttachmentCommandArchive;
struct InsertAttachmentCommandArchiveDefaultTypeInternal;
extern InsertAttachmentCommandArchiveDefaultTypeInternal _InsertAttachmentCommandArchive_default_instance_;
class InsertColumnsCommandArchive;
struct InsertColumnsCommandArchiveDefaultTypeInternal;
extern InsertColumnsCommandArchiveDefaultTypeInternal _InsertColumnsCommandArchive_default_instance_;
class InsertRowsCommandArchive;
struct InsertRowsCommandArchiveDefaultTypeInternal;
extern InsertRowsCommandArchiveDefaultTypeInternal _InsertRowsCommandArchive_default_instance_;
class MergeCellsCommandArchive;
struct MergeCellsCommandArchiveDefaultTypeInternal;
extern MergeCellsCommandArchiveDefaultTypeInternal _MergeCellsCommandArchive_default_instance_;
class ModifyHyperlinkCommandArchive;
struct ModifyHyperlinkCommandArchiveDefaultTypeInternal;
extern ModifyHyperlinkCommandArchiveDefaultTypeInternal _ModifyHyperlinkCommandArchive_default_instance_;
class ModifyRubyTextCommandArchive;
struct ModifyRubyTextCommandArchiveDefaultTypeInternal;
extern ModifyRubyTextCommandArchiveDefaultTypeInternal _ModifyRubyTextCommandArchive_default_instance_;
class ModifyTOCSettingsBaseCommandArchive;
struct ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal;
extern ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal _ModifyTOCSettingsBaseCommandArchive_default_instance_;
class ModifyTOCSettingsForTOCInfoCommandArchive;
struct ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal;
extern ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal _ModifyTOCSettingsForTOCInfoCommandArchive_default_instance_;
class ModifyTOCSettingsPresetForThemeCommandArchive;
struct ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal;
extern ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal _ModifyTOCSettingsPresetForThemeCommandArchive_default_instance_;
class MoveColumnsCommandArchive;
struct MoveColumnsCommandArchiveDefaultTypeInternal;
extern MoveColumnsCommandArchiveDefaultTypeInternal _MoveColumnsCommandArchive_default_instance_;
class MoveRowsCommandArchive;
struct MoveRowsCommandArchiveDefaultTypeInternal;
extern MoveRowsCommandArchiveDefaultTypeInternal _MoveRowsCommandArchive_default_instance_;
class RemoveColumnsCommandArchive;
struct RemoveColumnsCommandArchiveDefaultTypeInternal;
extern RemoveColumnsCommandArchiveDefaultTypeInternal _RemoveColumnsCommandArchive_default_instance_;
class RemoveHyperlinkCommandArchive;
struct RemoveHyperlinkCommandArchiveDefaultTypeInternal;
extern RemoveHyperlinkCommandArchiveDefaultTypeInternal _RemoveHyperlinkCommandArchive_default_instance_;
class RemoveRowsCommandArchive;
struct RemoveRowsCommandArchiveDefaultTypeInternal;
extern RemoveRowsCommandArchiveDefaultTypeInternal _RemoveRowsCommandArchive_default_instance_;
class RemoveRubyTextCommandArchive;
struct RemoveRubyTextCommandArchiveDefaultTypeInternal;
extern RemoveRubyTextCommandArchiveDefaultTypeInternal _RemoveRubyTextCommandArchive_default_instance_;
class ReplaceAllTextCommandArchive;
struct ReplaceAllTextCommandArchiveDefaultTypeInternal;
extern ReplaceAllTextCommandArchiveDefaultTypeInternal _ReplaceAllTextCommandArchive_default_instance_;
class ReplaceAllUsesOfStyleCommandArchive;
struct ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal;
extern ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal _ReplaceAllUsesOfStyleCommandArchive_default_instance_;
class SetColumnStyleCommandArchive;
struct SetColumnStyleCommandArchiveDefaultTypeInternal;
extern SetColumnStyleCommandArchiveDefaultTypeInternal _SetColumnStyleCommandArchive_default_instance_;
class ShapeApplyPresetCommandArchive;
struct ShapeApplyPresetCommandArchiveDefaultTypeInternal;
extern ShapeApplyPresetCommandArchiveDefaultTypeInternal _ShapeApplyPresetCommandArchive_default_instance_;
class ShapePasteStyleCommandArchive;
struct ShapePasteStyleCommandArchiveDefaultTypeInternal;
extern ShapePasteStyleCommandArchiveDefaultTypeInternal _ShapePasteStyleCommandArchive_default_instance_;
class StyleBaseCommandArchive;
struct StyleBaseCommandArchiveDefaultTypeInternal;
extern StyleBaseCommandArchiveDefaultTypeInternal _StyleBaseCommandArchive_default_instance_;
class StyleCreateCommandArchive;
struct StyleCreateCommandArchiveDefaultTypeInternal;
extern StyleCreateCommandArchiveDefaultTypeInternal _StyleCreateCommandArchive_default_instance_;
class StyleDeleteCommandArchive;
struct StyleDeleteCommandArchiveDefaultTypeInternal;
extern StyleDeleteCommandArchiveDefaultTypeInternal _StyleDeleteCommandArchive_default_instance_;
class StyleRenameCommandArchive;
struct StyleRenameCommandArchiveDefaultTypeInternal;
extern StyleRenameCommandArchiveDefaultTypeInternal _StyleRenameCommandArchive_default_instance_;
class StyleReorderCommandArchive;
struct StyleReorderCommandArchiveDefaultTypeInternal;
extern StyleReorderCommandArchiveDefaultTypeInternal _StyleReorderCommandArchive_default_instance_;
class StyleUpdateCommandArchive;
struct StyleUpdateCommandArchiveDefaultTypeInternal;
extern StyleUpdateCommandArchiveDefaultTypeInternal _StyleUpdateCommandArchive_default_instance_;
class StyleUpdatePropertyMapCommandArchive;
struct StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal;
extern StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal _StyleUpdatePropertyMapCommandArchive_default_instance_;
class TextApplyThemeCommandArchive;
struct TextApplyThemeCommandArchiveDefaultTypeInternal;
extern TextApplyThemeCommandArchiveDefaultTypeInternal _TextApplyThemeCommandArchive_default_instance_;
class TextCommandArchive;
struct TextCommandArchiveDefaultTypeInternal;
extern TextCommandArchiveDefaultTypeInternal _TextCommandArchive_default_instance_;
class UpdateDateTimeFieldCommandArchive;
struct UpdateDateTimeFieldCommandArchiveDefaultTypeInternal;
extern UpdateDateTimeFieldCommandArchiveDefaultTypeInternal _UpdateDateTimeFieldCommandArchive_default_instance_;
}  // namespace TSWP
PROTOBUF_NAMESPACE_OPEN
template<> ::TSWP::AnchorAttachmentCommandArchive* Arena::CreateMaybeMessage<::TSWP::AnchorAttachmentCommandArchive>(Arena*);
template<> ::TSWP::ApplyHighlightTextCommandArchive* Arena::CreateMaybeMessage<::TSWP::ApplyHighlightTextCommandArchive>(Arena*);
template<> ::TSWP::ApplyPlaceholderTextCommandArchive* Arena::CreateMaybeMessage<::TSWP::ApplyPlaceholderTextCommandArchive>(Arena*);
template<> ::TSWP::ApplyRubyTextCommandArchive* Arena::CreateMaybeMessage<::TSWP::ApplyRubyTextCommandArchive>(Arena*);
template<> ::TSWP::CreateHyperlinkCommandArchive* Arena::CreateMaybeMessage<::TSWP::CreateHyperlinkCommandArchive>(Arena*);
template<> ::TSWP::DummyCommandArchive* Arena::CreateMaybeMessage<::TSWP::DummyCommandArchive>(Arena*);
template<> ::TSWP::FormatTextCommandArchive* Arena::CreateMaybeMessage<::TSWP::FormatTextCommandArchive>(Arena*);
template<> ::TSWP::InsertAttachmentCommandArchive* Arena::CreateMaybeMessage<::TSWP::InsertAttachmentCommandArchive>(Arena*);
template<> ::TSWP::InsertColumnsCommandArchive* Arena::CreateMaybeMessage<::TSWP::InsertColumnsCommandArchive>(Arena*);
template<> ::TSWP::InsertRowsCommandArchive* Arena::CreateMaybeMessage<::TSWP::InsertRowsCommandArchive>(Arena*);
template<> ::TSWP::MergeCellsCommandArchive* Arena::CreateMaybeMessage<::TSWP::MergeCellsCommandArchive>(Arena*);
template<> ::TSWP::ModifyHyperlinkCommandArchive* Arena::CreateMaybeMessage<::TSWP::ModifyHyperlinkCommandArchive>(Arena*);
template<> ::TSWP::ModifyRubyTextCommandArchive* Arena::CreateMaybeMessage<::TSWP::ModifyRubyTextCommandArchive>(Arena*);
template<> ::TSWP::ModifyTOCSettingsBaseCommandArchive* Arena::CreateMaybeMessage<::TSWP::ModifyTOCSettingsBaseCommandArchive>(Arena*);
template<> ::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive* Arena::CreateMaybeMessage<::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive>(Arena*);
template<> ::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive* Arena::CreateMaybeMessage<::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive>(Arena*);
template<> ::TSWP::MoveColumnsCommandArchive* Arena::CreateMaybeMessage<::TSWP::MoveColumnsCommandArchive>(Arena*);
template<> ::TSWP::MoveRowsCommandArchive* Arena::CreateMaybeMessage<::TSWP::MoveRowsCommandArchive>(Arena*);
template<> ::TSWP::RemoveColumnsCommandArchive* Arena::CreateMaybeMessage<::TSWP::RemoveColumnsCommandArchive>(Arena*);
template<> ::TSWP::RemoveHyperlinkCommandArchive* Arena::CreateMaybeMessage<::TSWP::RemoveHyperlinkCommandArchive>(Arena*);
template<> ::TSWP::RemoveRowsCommandArchive* Arena::CreateMaybeMessage<::TSWP::RemoveRowsCommandArchive>(Arena*);
template<> ::TSWP::RemoveRubyTextCommandArchive* Arena::CreateMaybeMessage<::TSWP::RemoveRubyTextCommandArchive>(Arena*);
template<> ::TSWP::ReplaceAllTextCommandArchive* Arena::CreateMaybeMessage<::TSWP::ReplaceAllTextCommandArchive>(Arena*);
template<> ::TSWP::ReplaceAllUsesOfStyleCommandArchive* Arena::CreateMaybeMessage<::TSWP::ReplaceAllUsesOfStyleCommandArchive>(Arena*);
template<> ::TSWP::SetColumnStyleCommandArchive* Arena::CreateMaybeMessage<::TSWP::SetColumnStyleCommandArchive>(Arena*);
template<> ::TSWP::ShapeApplyPresetCommandArchive* Arena::CreateMaybeMessage<::TSWP::ShapeApplyPresetCommandArchive>(Arena*);
template<> ::TSWP::ShapePasteStyleCommandArchive* Arena::CreateMaybeMessage<::TSWP::ShapePasteStyleCommandArchive>(Arena*);
template<> ::TSWP::StyleBaseCommandArchive* Arena::CreateMaybeMessage<::TSWP::StyleBaseCommandArchive>(Arena*);
template<> ::TSWP::StyleCreateCommandArchive* Arena::CreateMaybeMessage<::TSWP::StyleCreateCommandArchive>(Arena*);
template<> ::TSWP::StyleDeleteCommandArchive* Arena::CreateMaybeMessage<::TSWP::StyleDeleteCommandArchive>(Arena*);
template<> ::TSWP::StyleRenameCommandArchive* Arena::CreateMaybeMessage<::TSWP::StyleRenameCommandArchive>(Arena*);
template<> ::TSWP::StyleReorderCommandArchive* Arena::CreateMaybeMessage<::TSWP::StyleReorderCommandArchive>(Arena*);
template<> ::TSWP::StyleUpdateCommandArchive* Arena::CreateMaybeMessage<::TSWP::StyleUpdateCommandArchive>(Arena*);
template<> ::TSWP::StyleUpdatePropertyMapCommandArchive* Arena::CreateMaybeMessage<::TSWP::StyleUpdatePropertyMapCommandArchive>(Arena*);
template<> ::TSWP::TextApplyThemeCommandArchive* Arena::CreateMaybeMessage<::TSWP::TextApplyThemeCommandArchive>(Arena*);
template<> ::TSWP::TextCommandArchive* Arena::CreateMaybeMessage<::TSWP::TextCommandArchive>(Arena*);
template<> ::TSWP::UpdateDateTimeFieldCommandArchive* Arena::CreateMaybeMessage<::TSWP::UpdateDateTimeFieldCommandArchive>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TSWP {

enum TextCommandArchive_Kind : int {
  TextCommandArchive_Kind_kKindContained = 0,
  TextCommandArchive_Kind_kKindReplaceText = 1,
  TextCommandArchive_Kind_kKindPaste = 2,
  TextCommandArchive_Kind_kKindParagraphStyle = 3,
  TextCommandArchive_Kind_kKindListStyle = 4,
  TextCommandArchive_Kind_kKindIndentParagraphLevel = 5,
  TextCommandArchive_Kind_kKindDragText = 6,
  TextCommandArchive_Kind_kKindPasteStyle = 7,
  TextCommandArchive_Kind_kKindApplyChangesInRange = 8,
  TextCommandArchive_Kind_kKindSetParagraphLevel = 9,
  TextCommandArchive_Kind_kKindInsertCitationField = 10,
  TextCommandArchive_Kind_kKindInsertBibliographyEntry = 11,
  TextCommandArchive_Kind_kKindFormatCitationFields = 12,
  TextCommandArchive_Kind_kKindInsertTOCSmartField = 13,
  TextCommandArchive_Kind_kKindInsertDateTimeField = 14,
  TextCommandArchive_Kind_kKindUpdateDateTimeField = 15,
  TextCommandArchive_Kind_kKindSetParagraphFirstTopicNumber = 16,
  TextCommandArchive_Kind_kKindCharacterStyle = 17,
  TextCommandArchive_Kind_kKindRevertStyles = 18,
  TextCommandArchive_Kind_kKindSetParagraphBidi = 19
};
bool TextCommandArchive_Kind_IsValid(int value);
constexpr TextCommandArchive_Kind TextCommandArchive_Kind_Kind_MIN = TextCommandArchive_Kind_kKindContained;
constexpr TextCommandArchive_Kind TextCommandArchive_Kind_Kind_MAX = TextCommandArchive_Kind_kKindSetParagraphBidi;
constexpr int TextCommandArchive_Kind_Kind_ARRAYSIZE = TextCommandArchive_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextCommandArchive_Kind_descriptor();
template<typename T>
inline const std::string& TextCommandArchive_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextCommandArchive_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextCommandArchive_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextCommandArchive_Kind_descriptor(), enum_t_value);
}
inline bool TextCommandArchive_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextCommandArchive_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextCommandArchive_Kind>(
    TextCommandArchive_Kind_descriptor(), name, value);
}
// ===================================================================

class DummyCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.DummyCommandArchive) */ {
 public:
  inline DummyCommandArchive() : DummyCommandArchive(nullptr) {}
  ~DummyCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR DummyCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DummyCommandArchive(const DummyCommandArchive& from);
  DummyCommandArchive(DummyCommandArchive&& from) noexcept
    : DummyCommandArchive() {
    *this = ::std::move(from);
  }

  inline DummyCommandArchive& operator=(const DummyCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DummyCommandArchive& operator=(DummyCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DummyCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DummyCommandArchive* internal_default_instance() {
    return reinterpret_cast<const DummyCommandArchive*>(
               &_DummyCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DummyCommandArchive& a, DummyCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DummyCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DummyCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DummyCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DummyCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DummyCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DummyCommandArchive& from) {
    DummyCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DummyCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.DummyCommandArchive";
  }
  protected:
  explicit DummyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFooFieldNumber = 1,
  };
  // required uint32 foo = 1;
  bool has_foo() const;
  private:
  bool _internal_has_foo() const;
  public:
  void clear_foo();
  uint32_t foo() const;
  void set_foo(uint32_t value);
  private:
  uint32_t _internal_foo() const;
  void _internal_set_foo(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.DummyCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t foo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class TextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.TextCommandArchive) */ {
 public:
  inline TextCommandArchive() : TextCommandArchive(nullptr) {}
  ~TextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR TextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextCommandArchive(const TextCommandArchive& from);
  TextCommandArchive(TextCommandArchive&& from) noexcept
    : TextCommandArchive() {
    *this = ::std::move(from);
  }

  inline TextCommandArchive& operator=(const TextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextCommandArchive& operator=(TextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const TextCommandArchive*>(
               &_TextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TextCommandArchive& a, TextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextCommandArchive& from) {
    TextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.TextCommandArchive";
  }
  protected:
  explicit TextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TextCommandArchive_Kind Kind;
  static constexpr Kind kKindContained =
    TextCommandArchive_Kind_kKindContained;
  static constexpr Kind kKindReplaceText =
    TextCommandArchive_Kind_kKindReplaceText;
  static constexpr Kind kKindPaste =
    TextCommandArchive_Kind_kKindPaste;
  static constexpr Kind kKindParagraphStyle =
    TextCommandArchive_Kind_kKindParagraphStyle;
  static constexpr Kind kKindListStyle =
    TextCommandArchive_Kind_kKindListStyle;
  static constexpr Kind kKindIndentParagraphLevel =
    TextCommandArchive_Kind_kKindIndentParagraphLevel;
  static constexpr Kind kKindDragText =
    TextCommandArchive_Kind_kKindDragText;
  static constexpr Kind kKindPasteStyle =
    TextCommandArchive_Kind_kKindPasteStyle;
  static constexpr Kind kKindApplyChangesInRange =
    TextCommandArchive_Kind_kKindApplyChangesInRange;
  static constexpr Kind kKindSetParagraphLevel =
    TextCommandArchive_Kind_kKindSetParagraphLevel;
  static constexpr Kind kKindInsertCitationField =
    TextCommandArchive_Kind_kKindInsertCitationField;
  static constexpr Kind kKindInsertBibliographyEntry =
    TextCommandArchive_Kind_kKindInsertBibliographyEntry;
  static constexpr Kind kKindFormatCitationFields =
    TextCommandArchive_Kind_kKindFormatCitationFields;
  static constexpr Kind kKindInsertTOCSmartField =
    TextCommandArchive_Kind_kKindInsertTOCSmartField;
  static constexpr Kind kKindInsertDateTimeField =
    TextCommandArchive_Kind_kKindInsertDateTimeField;
  static constexpr Kind kKindUpdateDateTimeField =
    TextCommandArchive_Kind_kKindUpdateDateTimeField;
  static constexpr Kind kKindSetParagraphFirstTopicNumber =
    TextCommandArchive_Kind_kKindSetParagraphFirstTopicNumber;
  static constexpr Kind kKindCharacterStyle =
    TextCommandArchive_Kind_kKindCharacterStyle;
  static constexpr Kind kKindRevertStyles =
    TextCommandArchive_Kind_kKindRevertStyles;
  static constexpr Kind kKindSetParagraphBidi =
    TextCommandArchive_Kind_kKindSetParagraphBidi;
  static inline bool Kind_IsValid(int value) {
    return TextCommandArchive_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    TextCommandArchive_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    TextCommandArchive_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    TextCommandArchive_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return TextCommandArchive_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return TextCommandArchive_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return TextCommandArchive_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 3,
    kRestoreRangeLocationFieldNumber = 4,
    kRestoreRangeLengthFieldNumber = 5,
    kRedoRestoreRangeLocationFieldNumber = 6,
    kRedoRestoreRangeLengthFieldNumber = 7,
    kTextCommandFlagsFieldNumber = 9,
    kKindFieldNumber = 10,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 restore_range_location = 4;
  bool has_restore_range_location() const;
  private:
  bool _internal_has_restore_range_location() const;
  public:
  void clear_restore_range_location();
  uint32_t restore_range_location() const;
  void set_restore_range_location(uint32_t value);
  private:
  uint32_t _internal_restore_range_location() const;
  void _internal_set_restore_range_location(uint32_t value);
  public:

  // optional uint32 restore_range_length = 5;
  bool has_restore_range_length() const;
  private:
  bool _internal_has_restore_range_length() const;
  public:
  void clear_restore_range_length();
  uint32_t restore_range_length() const;
  void set_restore_range_length(uint32_t value);
  private:
  uint32_t _internal_restore_range_length() const;
  void _internal_set_restore_range_length(uint32_t value);
  public:

  // optional uint32 redo_restore_range_location = 6;
  bool has_redo_restore_range_location() const;
  private:
  bool _internal_has_redo_restore_range_location() const;
  public:
  void clear_redo_restore_range_location();
  uint32_t redo_restore_range_location() const;
  void set_redo_restore_range_location(uint32_t value);
  private:
  uint32_t _internal_redo_restore_range_location() const;
  void _internal_set_redo_restore_range_location(uint32_t value);
  public:

  // optional uint32 redo_restore_range_length = 7;
  bool has_redo_restore_range_length() const;
  private:
  bool _internal_has_redo_restore_range_length() const;
  public:
  void clear_redo_restore_range_length();
  uint32_t redo_restore_range_length() const;
  void set_redo_restore_range_length(uint32_t value);
  private:
  uint32_t _internal_redo_restore_range_length() const;
  void _internal_set_redo_restore_range_length(uint32_t value);
  public:

  // optional uint32 text_command_flags = 9;
  bool has_text_command_flags() const;
  private:
  bool _internal_has_text_command_flags() const;
  public:
  void clear_text_command_flags();
  uint32_t text_command_flags() const;
  void set_text_command_flags(uint32_t value);
  private:
  uint32_t _internal_text_command_flags() const;
  void _internal_set_text_command_flags(uint32_t value);
  public:

  // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::TSWP::TextCommandArchive_Kind kind() const;
  void set_kind(::TSWP::TextCommandArchive_Kind value);
  private:
  ::TSWP::TextCommandArchive_Kind _internal_kind() const;
  void _internal_set_kind(::TSWP::TextCommandArchive_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.TextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t restore_range_location_;
    uint32_t restore_range_length_;
    uint32_t redo_restore_range_location_;
    uint32_t redo_restore_range_length_;
    uint32_t text_command_flags_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ReplaceAllTextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ReplaceAllTextCommandArchive) */ {
 public:
  inline ReplaceAllTextCommandArchive() : ReplaceAllTextCommandArchive(nullptr) {}
  ~ReplaceAllTextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ReplaceAllTextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaceAllTextCommandArchive(const ReplaceAllTextCommandArchive& from);
  ReplaceAllTextCommandArchive(ReplaceAllTextCommandArchive&& from) noexcept
    : ReplaceAllTextCommandArchive() {
    *this = ::std::move(from);
  }

  inline ReplaceAllTextCommandArchive& operator=(const ReplaceAllTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaceAllTextCommandArchive& operator=(ReplaceAllTextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaceAllTextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaceAllTextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ReplaceAllTextCommandArchive*>(
               &_ReplaceAllTextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReplaceAllTextCommandArchive& a, ReplaceAllTextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaceAllTextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaceAllTextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplaceAllTextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplaceAllTextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplaceAllTextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplaceAllTextCommandArchive& from) {
    ReplaceAllTextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaceAllTextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ReplaceAllTextCommandArchive";
  }
  protected:
  explicit ReplaceAllTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 3,
  };
  // optional .TSK.ReplaceAllChildCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::ReplaceAllChildCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::ReplaceAllChildCommandArchive* release_super();
  ::TSK::ReplaceAllChildCommandArchive* mutable_super();
  void set_allocated_super(::TSK::ReplaceAllChildCommandArchive* super);
  private:
  const ::TSK::ReplaceAllChildCommandArchive& _internal_super() const;
  ::TSK::ReplaceAllChildCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::ReplaceAllChildCommandArchive* super);
  ::TSK::ReplaceAllChildCommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // @@protoc_insertion_point(class_scope:TSWP.ReplaceAllTextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::ReplaceAllChildCommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class FormatTextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.FormatTextCommandArchive) */ {
 public:
  inline FormatTextCommandArchive() : FormatTextCommandArchive(nullptr) {}
  ~FormatTextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR FormatTextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormatTextCommandArchive(const FormatTextCommandArchive& from);
  FormatTextCommandArchive(FormatTextCommandArchive&& from) noexcept
    : FormatTextCommandArchive() {
    *this = ::std::move(from);
  }

  inline FormatTextCommandArchive& operator=(const FormatTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormatTextCommandArchive& operator=(FormatTextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormatTextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormatTextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const FormatTextCommandArchive*>(
               &_FormatTextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FormatTextCommandArchive& a, FormatTextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FormatTextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormatTextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormatTextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormatTextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormatTextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormatTextCommandArchive& from) {
    FormatTextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormatTextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.FormatTextCommandArchive";
  }
  protected:
  explicit FormatTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 3,
    kSelectionRangeLocationFieldNumber = 8,
    kSelectionRangeLengthFieldNumber = 9,
    kTextCommandFlagsFieldNumber = 11,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 8;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 9;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // optional uint32 text_command_flags = 11;
  bool has_text_command_flags() const;
  private:
  bool _internal_has_text_command_flags() const;
  public:
  void clear_text_command_flags();
  uint32_t text_command_flags() const;
  void set_text_command_flags(uint32_t value);
  private:
  uint32_t _internal_text_command_flags() const;
  void _internal_set_text_command_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.FormatTextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
    uint32_t text_command_flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class SetColumnStyleCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.SetColumnStyleCommandArchive) */ {
 public:
  inline SetColumnStyleCommandArchive() : SetColumnStyleCommandArchive(nullptr) {}
  ~SetColumnStyleCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR SetColumnStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetColumnStyleCommandArchive(const SetColumnStyleCommandArchive& from);
  SetColumnStyleCommandArchive(SetColumnStyleCommandArchive&& from) noexcept
    : SetColumnStyleCommandArchive() {
    *this = ::std::move(from);
  }

  inline SetColumnStyleCommandArchive& operator=(const SetColumnStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetColumnStyleCommandArchive& operator=(SetColumnStyleCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetColumnStyleCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetColumnStyleCommandArchive* internal_default_instance() {
    return reinterpret_cast<const SetColumnStyleCommandArchive*>(
               &_SetColumnStyleCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetColumnStyleCommandArchive& a, SetColumnStyleCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SetColumnStyleCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetColumnStyleCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetColumnStyleCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetColumnStyleCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetColumnStyleCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetColumnStyleCommandArchive& from) {
    SetColumnStyleCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetColumnStyleCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.SetColumnStyleCommandArchive";
  }
  protected:
  explicit SetColumnStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 3,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // @@protoc_insertion_point(class_scope:TSWP.SetColumnStyleCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ReplaceAllUsesOfStyleCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ReplaceAllUsesOfStyleCommandArchive) */ {
 public:
  inline ReplaceAllUsesOfStyleCommandArchive() : ReplaceAllUsesOfStyleCommandArchive(nullptr) {}
  ~ReplaceAllUsesOfStyleCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ReplaceAllUsesOfStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaceAllUsesOfStyleCommandArchive(const ReplaceAllUsesOfStyleCommandArchive& from);
  ReplaceAllUsesOfStyleCommandArchive(ReplaceAllUsesOfStyleCommandArchive&& from) noexcept
    : ReplaceAllUsesOfStyleCommandArchive() {
    *this = ::std::move(from);
  }

  inline ReplaceAllUsesOfStyleCommandArchive& operator=(const ReplaceAllUsesOfStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaceAllUsesOfStyleCommandArchive& operator=(ReplaceAllUsesOfStyleCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaceAllUsesOfStyleCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaceAllUsesOfStyleCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ReplaceAllUsesOfStyleCommandArchive*>(
               &_ReplaceAllUsesOfStyleCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReplaceAllUsesOfStyleCommandArchive& a, ReplaceAllUsesOfStyleCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaceAllUsesOfStyleCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaceAllUsesOfStyleCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplaceAllUsesOfStyleCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplaceAllUsesOfStyleCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplaceAllUsesOfStyleCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplaceAllUsesOfStyleCommandArchive& from) {
    ReplaceAllUsesOfStyleCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaceAllUsesOfStyleCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ReplaceAllUsesOfStyleCommandArchive";
  }
  protected:
  explicit ReplaceAllUsesOfStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 3,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // @@protoc_insertion_point(class_scope:TSWP.ReplaceAllUsesOfStyleCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class InsertAttachmentCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.InsertAttachmentCommandArchive) */ {
 public:
  inline InsertAttachmentCommandArchive() : InsertAttachmentCommandArchive(nullptr) {}
  ~InsertAttachmentCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR InsertAttachmentCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertAttachmentCommandArchive(const InsertAttachmentCommandArchive& from);
  InsertAttachmentCommandArchive(InsertAttachmentCommandArchive&& from) noexcept
    : InsertAttachmentCommandArchive() {
    *this = ::std::move(from);
  }

  inline InsertAttachmentCommandArchive& operator=(const InsertAttachmentCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertAttachmentCommandArchive& operator=(InsertAttachmentCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertAttachmentCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertAttachmentCommandArchive* internal_default_instance() {
    return reinterpret_cast<const InsertAttachmentCommandArchive*>(
               &_InsertAttachmentCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InsertAttachmentCommandArchive& a, InsertAttachmentCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertAttachmentCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertAttachmentCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertAttachmentCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertAttachmentCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertAttachmentCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertAttachmentCommandArchive& from) {
    InsertAttachmentCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertAttachmentCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.InsertAttachmentCommandArchive";
  }
  protected:
  explicit InsertAttachmentCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kAttachmentFieldNumber = 5,
    kUndoTransactionFieldNumber = 6,
    kSelectionRangeLocationFieldNumber = 3,
    kSelectionRangeLengthFieldNumber = 4,
    kTextCommandFlagsFieldNumber = 7,
    kRedoRestoreRangeLocationFieldNumber = 8,
    kRedoRestoreRangeLengthFieldNumber = 9,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSP.Reference attachment = 5;
  bool has_attachment() const;
  private:
  bool _internal_has_attachment() const;
  public:
  void clear_attachment();
  const ::TSP::Reference& attachment() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_attachment();
  ::TSP::Reference* mutable_attachment();
  void set_allocated_attachment(::TSP::Reference* attachment);
  private:
  const ::TSP::Reference& _internal_attachment() const;
  ::TSP::Reference* _internal_mutable_attachment();
  public:
  void unsafe_arena_set_allocated_attachment(
      ::TSP::Reference* attachment);
  ::TSP::Reference* unsafe_arena_release_attachment();

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 3;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 4;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // optional uint32 text_command_flags = 7;
  bool has_text_command_flags() const;
  private:
  bool _internal_has_text_command_flags() const;
  public:
  void clear_text_command_flags();
  uint32_t text_command_flags() const;
  void set_text_command_flags(uint32_t value);
  private:
  uint32_t _internal_text_command_flags() const;
  void _internal_set_text_command_flags(uint32_t value);
  public:

  // optional uint32 redo_restore_range_location = 8;
  bool has_redo_restore_range_location() const;
  private:
  bool _internal_has_redo_restore_range_location() const;
  public:
  void clear_redo_restore_range_location();
  uint32_t redo_restore_range_location() const;
  void set_redo_restore_range_location(uint32_t value);
  private:
  uint32_t _internal_redo_restore_range_location() const;
  void _internal_set_redo_restore_range_location(uint32_t value);
  public:

  // optional uint32 redo_restore_range_length = 9;
  bool has_redo_restore_range_length() const;
  private:
  bool _internal_has_redo_restore_range_length() const;
  public:
  void clear_redo_restore_range_length();
  uint32_t redo_restore_range_length() const;
  void set_redo_restore_range_length(uint32_t value);
  private:
  uint32_t _internal_redo_restore_range_length() const;
  void _internal_set_redo_restore_range_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.InsertAttachmentCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSP::Reference* attachment_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
    uint32_t text_command_flags_;
    uint32_t redo_restore_range_location_;
    uint32_t redo_restore_range_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class InsertColumnsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.InsertColumnsCommandArchive) */ {
 public:
  inline InsertColumnsCommandArchive() : InsertColumnsCommandArchive(nullptr) {}
  ~InsertColumnsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR InsertColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertColumnsCommandArchive(const InsertColumnsCommandArchive& from);
  InsertColumnsCommandArchive(InsertColumnsCommandArchive&& from) noexcept
    : InsertColumnsCommandArchive() {
    *this = ::std::move(from);
  }

  inline InsertColumnsCommandArchive& operator=(const InsertColumnsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertColumnsCommandArchive& operator=(InsertColumnsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertColumnsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertColumnsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const InsertColumnsCommandArchive*>(
               &_InsertColumnsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InsertColumnsCommandArchive& a, InsertColumnsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertColumnsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertColumnsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertColumnsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertColumnsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertColumnsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertColumnsCommandArchive& from) {
    InsertColumnsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertColumnsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.InsertColumnsCommandArchive";
  }
  protected:
  explicit InsertColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kColumnIndexFieldNumber = 3,
    kColumnCountFieldNumber = 4,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 column_index = 3;
  bool has_column_index() const;
  private:
  bool _internal_has_column_index() const;
  public:
  void clear_column_index();
  uint32_t column_index() const;
  void set_column_index(uint32_t value);
  private:
  uint32_t _internal_column_index() const;
  void _internal_set_column_index(uint32_t value);
  public:

  // optional uint32 column_count = 4;
  bool has_column_count() const;
  private:
  bool _internal_has_column_count() const;
  public:
  void clear_column_count();
  uint32_t column_count() const;
  void set_column_count(uint32_t value);
  private:
  uint32_t _internal_column_count() const;
  void _internal_set_column_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.InsertColumnsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t column_index_;
    uint32_t column_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class InsertRowsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.InsertRowsCommandArchive) */ {
 public:
  inline InsertRowsCommandArchive() : InsertRowsCommandArchive(nullptr) {}
  ~InsertRowsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR InsertRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRowsCommandArchive(const InsertRowsCommandArchive& from);
  InsertRowsCommandArchive(InsertRowsCommandArchive&& from) noexcept
    : InsertRowsCommandArchive() {
    *this = ::std::move(from);
  }

  inline InsertRowsCommandArchive& operator=(const InsertRowsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRowsCommandArchive& operator=(InsertRowsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRowsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRowsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const InsertRowsCommandArchive*>(
               &_InsertRowsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InsertRowsCommandArchive& a, InsertRowsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRowsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRowsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRowsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRowsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRowsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRowsCommandArchive& from) {
    InsertRowsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRowsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.InsertRowsCommandArchive";
  }
  protected:
  explicit InsertRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kRowIndexFieldNumber = 3,
    kRowCountFieldNumber = 4,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 row_index = 3;
  bool has_row_index() const;
  private:
  bool _internal_has_row_index() const;
  public:
  void clear_row_index();
  uint32_t row_index() const;
  void set_row_index(uint32_t value);
  private:
  uint32_t _internal_row_index() const;
  void _internal_set_row_index(uint32_t value);
  public:

  // optional uint32 row_count = 4;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  uint32_t row_count() const;
  void set_row_count(uint32_t value);
  private:
  uint32_t _internal_row_count() const;
  void _internal_set_row_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.InsertRowsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t row_index_;
    uint32_t row_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveColumnsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.RemoveColumnsCommandArchive) */ {
 public:
  inline RemoveColumnsCommandArchive() : RemoveColumnsCommandArchive(nullptr) {}
  ~RemoveColumnsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR RemoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveColumnsCommandArchive(const RemoveColumnsCommandArchive& from);
  RemoveColumnsCommandArchive(RemoveColumnsCommandArchive&& from) noexcept
    : RemoveColumnsCommandArchive() {
    *this = ::std::move(from);
  }

  inline RemoveColumnsCommandArchive& operator=(const RemoveColumnsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveColumnsCommandArchive& operator=(RemoveColumnsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveColumnsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveColumnsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const RemoveColumnsCommandArchive*>(
               &_RemoveColumnsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RemoveColumnsCommandArchive& a, RemoveColumnsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveColumnsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveColumnsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveColumnsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveColumnsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveColumnsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveColumnsCommandArchive& from) {
    RemoveColumnsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveColumnsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.RemoveColumnsCommandArchive";
  }
  protected:
  explicit RemoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kColumnIndexFieldNumber = 3,
    kColumnCountFieldNumber = 4,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 column_index = 3;
  bool has_column_index() const;
  private:
  bool _internal_has_column_index() const;
  public:
  void clear_column_index();
  uint32_t column_index() const;
  void set_column_index(uint32_t value);
  private:
  uint32_t _internal_column_index() const;
  void _internal_set_column_index(uint32_t value);
  public:

  // optional uint32 column_count = 4;
  bool has_column_count() const;
  private:
  bool _internal_has_column_count() const;
  public:
  void clear_column_count();
  uint32_t column_count() const;
  void set_column_count(uint32_t value);
  private:
  uint32_t _internal_column_count() const;
  void _internal_set_column_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.RemoveColumnsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t column_index_;
    uint32_t column_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveRowsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.RemoveRowsCommandArchive) */ {
 public:
  inline RemoveRowsCommandArchive() : RemoveRowsCommandArchive(nullptr) {}
  ~RemoveRowsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR RemoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRowsCommandArchive(const RemoveRowsCommandArchive& from);
  RemoveRowsCommandArchive(RemoveRowsCommandArchive&& from) noexcept
    : RemoveRowsCommandArchive() {
    *this = ::std::move(from);
  }

  inline RemoveRowsCommandArchive& operator=(const RemoveRowsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRowsCommandArchive& operator=(RemoveRowsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRowsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRowsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const RemoveRowsCommandArchive*>(
               &_RemoveRowsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RemoveRowsCommandArchive& a, RemoveRowsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRowsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRowsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRowsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRowsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveRowsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveRowsCommandArchive& from) {
    RemoveRowsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRowsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.RemoveRowsCommandArchive";
  }
  protected:
  explicit RemoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kRowIndexFieldNumber = 3,
    kRowCountFieldNumber = 4,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 row_index = 3;
  bool has_row_index() const;
  private:
  bool _internal_has_row_index() const;
  public:
  void clear_row_index();
  uint32_t row_index() const;
  void set_row_index(uint32_t value);
  private:
  uint32_t _internal_row_index() const;
  void _internal_set_row_index(uint32_t value);
  public:

  // optional uint32 row_count = 4;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  uint32_t row_count() const;
  void set_row_count(uint32_t value);
  private:
  uint32_t _internal_row_count() const;
  void _internal_set_row_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.RemoveRowsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t row_index_;
    uint32_t row_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MergeCellsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.MergeCellsCommandArchive) */ {
 public:
  inline MergeCellsCommandArchive() : MergeCellsCommandArchive(nullptr) {}
  ~MergeCellsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MergeCellsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MergeCellsCommandArchive(const MergeCellsCommandArchive& from);
  MergeCellsCommandArchive(MergeCellsCommandArchive&& from) noexcept
    : MergeCellsCommandArchive() {
    *this = ::std::move(from);
  }

  inline MergeCellsCommandArchive& operator=(const MergeCellsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeCellsCommandArchive& operator=(MergeCellsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeCellsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeCellsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MergeCellsCommandArchive*>(
               &_MergeCellsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MergeCellsCommandArchive& a, MergeCellsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeCellsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeCellsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergeCellsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MergeCellsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MergeCellsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MergeCellsCommandArchive& from) {
    MergeCellsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MergeCellsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.MergeCellsCommandArchive";
  }
  protected:
  explicit MergeCellsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 7,
    kRowFieldNumber = 3,
    kColumnFieldNumber = 4,
    kRowCountFieldNumber = 5,
    kColumnCountFieldNumber = 6,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 7;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 row = 3;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  uint32_t row() const;
  void set_row(uint32_t value);
  private:
  uint32_t _internal_row() const;
  void _internal_set_row(uint32_t value);
  public:

  // optional uint32 column = 4;
  bool has_column() const;
  private:
  bool _internal_has_column() const;
  public:
  void clear_column();
  uint32_t column() const;
  void set_column(uint32_t value);
  private:
  uint32_t _internal_column() const;
  void _internal_set_column(uint32_t value);
  public:

  // optional uint32 row_count = 5;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  uint32_t row_count() const;
  void set_row_count(uint32_t value);
  private:
  uint32_t _internal_row_count() const;
  void _internal_set_row_count(uint32_t value);
  public:

  // optional uint32 column_count = 6;
  bool has_column_count() const;
  private:
  bool _internal_has_column_count() const;
  public:
  void clear_column_count();
  uint32_t column_count() const;
  void set_column_count(uint32_t value);
  private:
  uint32_t _internal_column_count() const;
  void _internal_set_column_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.MergeCellsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t row_;
    uint32_t column_;
    uint32_t row_count_;
    uint32_t column_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ApplyPlaceholderTextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ApplyPlaceholderTextCommandArchive) */ {
 public:
  inline ApplyPlaceholderTextCommandArchive() : ApplyPlaceholderTextCommandArchive(nullptr) {}
  ~ApplyPlaceholderTextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ApplyPlaceholderTextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyPlaceholderTextCommandArchive(const ApplyPlaceholderTextCommandArchive& from);
  ApplyPlaceholderTextCommandArchive(ApplyPlaceholderTextCommandArchive&& from) noexcept
    : ApplyPlaceholderTextCommandArchive() {
    *this = ::std::move(from);
  }

  inline ApplyPlaceholderTextCommandArchive& operator=(const ApplyPlaceholderTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyPlaceholderTextCommandArchive& operator=(ApplyPlaceholderTextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyPlaceholderTextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyPlaceholderTextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ApplyPlaceholderTextCommandArchive*>(
               &_ApplyPlaceholderTextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ApplyPlaceholderTextCommandArchive& a, ApplyPlaceholderTextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyPlaceholderTextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyPlaceholderTextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyPlaceholderTextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyPlaceholderTextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyPlaceholderTextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyPlaceholderTextCommandArchive& from) {
    ApplyPlaceholderTextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyPlaceholderTextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ApplyPlaceholderTextCommandArchive";
  }
  protected:
  explicit ApplyPlaceholderTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kSelectionRangeLocationFieldNumber = 3,
    kSelectionRangeLengthFieldNumber = 4,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 3;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 4;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.ApplyPlaceholderTextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ApplyHighlightTextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ApplyHighlightTextCommandArchive) */ {
 public:
  inline ApplyHighlightTextCommandArchive() : ApplyHighlightTextCommandArchive(nullptr) {}
  ~ApplyHighlightTextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ApplyHighlightTextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyHighlightTextCommandArchive(const ApplyHighlightTextCommandArchive& from);
  ApplyHighlightTextCommandArchive(ApplyHighlightTextCommandArchive&& from) noexcept
    : ApplyHighlightTextCommandArchive() {
    *this = ::std::move(from);
  }

  inline ApplyHighlightTextCommandArchive& operator=(const ApplyHighlightTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyHighlightTextCommandArchive& operator=(ApplyHighlightTextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyHighlightTextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyHighlightTextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ApplyHighlightTextCommandArchive*>(
               &_ApplyHighlightTextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ApplyHighlightTextCommandArchive& a, ApplyHighlightTextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyHighlightTextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyHighlightTextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyHighlightTextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyHighlightTextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyHighlightTextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyHighlightTextCommandArchive& from) {
    ApplyHighlightTextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyHighlightTextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ApplyHighlightTextCommandArchive";
  }
  protected:
  explicit ApplyHighlightTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kSelectionRangeLocationFieldNumber = 3,
    kSelectionRangeLengthFieldNumber = 4,
    kRemoveFieldNumber = 6,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 3;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 4;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // optional bool remove = 6;
  bool has_remove() const;
  private:
  bool _internal_has_remove() const;
  public:
  void clear_remove();
  bool remove() const;
  void set_remove(bool value);
  private:
  bool _internal_remove() const;
  void _internal_set_remove(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.ApplyHighlightTextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
    bool remove_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class CreateHyperlinkCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.CreateHyperlinkCommandArchive) */ {
 public:
  inline CreateHyperlinkCommandArchive() : CreateHyperlinkCommandArchive(nullptr) {}
  ~CreateHyperlinkCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR CreateHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateHyperlinkCommandArchive(const CreateHyperlinkCommandArchive& from);
  CreateHyperlinkCommandArchive(CreateHyperlinkCommandArchive&& from) noexcept
    : CreateHyperlinkCommandArchive() {
    *this = ::std::move(from);
  }

  inline CreateHyperlinkCommandArchive& operator=(const CreateHyperlinkCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateHyperlinkCommandArchive& operator=(CreateHyperlinkCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateHyperlinkCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateHyperlinkCommandArchive* internal_default_instance() {
    return reinterpret_cast<const CreateHyperlinkCommandArchive*>(
               &_CreateHyperlinkCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateHyperlinkCommandArchive& a, CreateHyperlinkCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateHyperlinkCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateHyperlinkCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateHyperlinkCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateHyperlinkCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateHyperlinkCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateHyperlinkCommandArchive& from) {
    CreateHyperlinkCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateHyperlinkCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.CreateHyperlinkCommandArchive";
  }
  protected:
  explicit CreateHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlRefFieldNumber = 5,
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 6,
    kSelectionRangeLocationFieldNumber = 3,
    kSelectionRangeLengthFieldNumber = 4,
  };
  // optional string url_ref = 5;
  bool has_url_ref() const;
  private:
  bool _internal_has_url_ref() const;
  public:
  void clear_url_ref();
  const std::string& url_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url_ref();
  PROTOBUF_NODISCARD std::string* release_url_ref();
  void set_allocated_url_ref(std::string* url_ref);
  private:
  const std::string& _internal_url_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_ref(const std::string& value);
  std::string* _internal_mutable_url_ref();
  public:

  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 3;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 4;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.CreateHyperlinkCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_ref_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveHyperlinkCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.RemoveHyperlinkCommandArchive) */ {
 public:
  inline RemoveHyperlinkCommandArchive() : RemoveHyperlinkCommandArchive(nullptr) {}
  ~RemoveHyperlinkCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR RemoveHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveHyperlinkCommandArchive(const RemoveHyperlinkCommandArchive& from);
  RemoveHyperlinkCommandArchive(RemoveHyperlinkCommandArchive&& from) noexcept
    : RemoveHyperlinkCommandArchive() {
    *this = ::std::move(from);
  }

  inline RemoveHyperlinkCommandArchive& operator=(const RemoveHyperlinkCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveHyperlinkCommandArchive& operator=(RemoveHyperlinkCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveHyperlinkCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveHyperlinkCommandArchive* internal_default_instance() {
    return reinterpret_cast<const RemoveHyperlinkCommandArchive*>(
               &_RemoveHyperlinkCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RemoveHyperlinkCommandArchive& a, RemoveHyperlinkCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveHyperlinkCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveHyperlinkCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveHyperlinkCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveHyperlinkCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveHyperlinkCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveHyperlinkCommandArchive& from) {
    RemoveHyperlinkCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveHyperlinkCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.RemoveHyperlinkCommandArchive";
  }
  protected:
  explicit RemoveHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kSelectionRangeLocationFieldNumber = 3,
    kSelectionRangeLengthFieldNumber = 4,
    kIsRemoveCharacterStyleFieldNumber = 6,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 3;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 4;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // optional bool is_remove_character_style = 6 [default = true];
  bool has_is_remove_character_style() const;
  private:
  bool _internal_has_is_remove_character_style() const;
  public:
  void clear_is_remove_character_style();
  bool is_remove_character_style() const;
  void set_is_remove_character_style(bool value);
  private:
  bool _internal_is_remove_character_style() const;
  void _internal_set_is_remove_character_style(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.RemoveHyperlinkCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
    bool is_remove_character_style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ModifyHyperlinkCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ModifyHyperlinkCommandArchive) */ {
 public:
  inline ModifyHyperlinkCommandArchive() : ModifyHyperlinkCommandArchive(nullptr) {}
  ~ModifyHyperlinkCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ModifyHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyHyperlinkCommandArchive(const ModifyHyperlinkCommandArchive& from);
  ModifyHyperlinkCommandArchive(ModifyHyperlinkCommandArchive&& from) noexcept
    : ModifyHyperlinkCommandArchive() {
    *this = ::std::move(from);
  }

  inline ModifyHyperlinkCommandArchive& operator=(const ModifyHyperlinkCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyHyperlinkCommandArchive& operator=(ModifyHyperlinkCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyHyperlinkCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyHyperlinkCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ModifyHyperlinkCommandArchive*>(
               &_ModifyHyperlinkCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ModifyHyperlinkCommandArchive& a, ModifyHyperlinkCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyHyperlinkCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyHyperlinkCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyHyperlinkCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyHyperlinkCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyHyperlinkCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyHyperlinkCommandArchive& from) {
    ModifyHyperlinkCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyHyperlinkCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ModifyHyperlinkCommandArchive";
  }
  protected:
  explicit ModifyHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayTextFieldNumber = 3,
    kUrlRefFieldNumber = 4,
    kSuperFieldNumber = 1,
    kHyperlinkFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
  };
  // optional string display_text = 3;
  bool has_display_text() const;
  private:
  bool _internal_has_display_text() const;
  public:
  void clear_display_text();
  const std::string& display_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_text();
  PROTOBUF_NODISCARD std::string* release_display_text();
  void set_allocated_display_text(std::string* display_text);
  private:
  const std::string& _internal_display_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_text(const std::string& value);
  std::string* _internal_mutable_display_text();
  public:

  // optional string url_ref = 4;
  bool has_url_ref() const;
  private:
  bool _internal_has_url_ref() const;
  public:
  void clear_url_ref();
  const std::string& url_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url_ref();
  PROTOBUF_NODISCARD std::string* release_url_ref();
  void set_allocated_url_ref(std::string* url_ref);
  private:
  const std::string& _internal_url_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_ref(const std::string& value);
  std::string* _internal_mutable_url_ref();
  public:

  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference hyperlink = 2;
  bool has_hyperlink() const;
  private:
  bool _internal_has_hyperlink() const;
  public:
  void clear_hyperlink();
  const ::TSP::Reference& hyperlink() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_hyperlink();
  ::TSP::Reference* mutable_hyperlink();
  void set_allocated_hyperlink(::TSP::Reference* hyperlink);
  private:
  const ::TSP::Reference& _internal_hyperlink() const;
  ::TSP::Reference* _internal_mutable_hyperlink();
  public:
  void unsafe_arena_set_allocated_hyperlink(
      ::TSP::Reference* hyperlink);
  ::TSP::Reference* unsafe_arena_release_hyperlink();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // @@protoc_insertion_point(class_scope:TSWP.ModifyHyperlinkCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_ref_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* hyperlink_;
    ::TSWP::UndoTransaction* undo_transaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class UpdateDateTimeFieldCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.UpdateDateTimeFieldCommandArchive) */ {
 public:
  inline UpdateDateTimeFieldCommandArchive() : UpdateDateTimeFieldCommandArchive(nullptr) {}
  ~UpdateDateTimeFieldCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR UpdateDateTimeFieldCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDateTimeFieldCommandArchive(const UpdateDateTimeFieldCommandArchive& from);
  UpdateDateTimeFieldCommandArchive(UpdateDateTimeFieldCommandArchive&& from) noexcept
    : UpdateDateTimeFieldCommandArchive() {
    *this = ::std::move(from);
  }

  inline UpdateDateTimeFieldCommandArchive& operator=(const UpdateDateTimeFieldCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDateTimeFieldCommandArchive& operator=(UpdateDateTimeFieldCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDateTimeFieldCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDateTimeFieldCommandArchive* internal_default_instance() {
    return reinterpret_cast<const UpdateDateTimeFieldCommandArchive*>(
               &_UpdateDateTimeFieldCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateDateTimeFieldCommandArchive& a, UpdateDateTimeFieldCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDateTimeFieldCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDateTimeFieldCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDateTimeFieldCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDateTimeFieldCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateDateTimeFieldCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateDateTimeFieldCommandArchive& from) {
    UpdateDateTimeFieldCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateDateTimeFieldCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.UpdateDateTimeFieldCommandArchive";
  }
  protected:
  explicit UpdateDateTimeFieldCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kDateTimeFieldFieldNumber = 2,
    kDateFieldNumber = 3,
    kDateStyleFieldNumber = 4,
    kTimeStyleFieldNumber = 5,
  };
  // optional .TSWP.TextCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::TextCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::TextCommandArchive* release_super();
  ::TSWP::TextCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::TextCommandArchive* super);
  private:
  const ::TSWP::TextCommandArchive& _internal_super() const;
  ::TSWP::TextCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::TextCommandArchive* super);
  ::TSWP::TextCommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference date_time_field = 2;
  bool has_date_time_field() const;
  private:
  bool _internal_has_date_time_field() const;
  public:
  void clear_date_time_field();
  const ::TSP::Reference& date_time_field() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_date_time_field();
  ::TSP::Reference* mutable_date_time_field();
  void set_allocated_date_time_field(::TSP::Reference* date_time_field);
  private:
  const ::TSP::Reference& _internal_date_time_field() const;
  ::TSP::Reference* _internal_mutable_date_time_field();
  public:
  void unsafe_arena_set_allocated_date_time_field(
      ::TSP::Reference* date_time_field);
  ::TSP::Reference* unsafe_arena_release_date_time_field();

  // optional .TSP.Date date = 3;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const ::TSP::Date& date() const;
  PROTOBUF_NODISCARD ::TSP::Date* release_date();
  ::TSP::Date* mutable_date();
  void set_allocated_date(::TSP::Date* date);
  private:
  const ::TSP::Date& _internal_date() const;
  ::TSP::Date* _internal_mutable_date();
  public:
  void unsafe_arena_set_allocated_date(
      ::TSP::Date* date);
  ::TSP::Date* unsafe_arena_release_date();

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
  bool has_date_style() const;
  private:
  bool _internal_has_date_style() const;
  public:
  void clear_date_style();
  ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle date_style() const;
  void set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);
  private:
  ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle _internal_date_style() const;
  void _internal_set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);
  public:

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
  bool has_time_style() const;
  private:
  bool _internal_has_time_style() const;
  public:
  void clear_time_style();
  ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle time_style() const;
  void set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);
  private:
  ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle _internal_time_style() const;
  void _internal_set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.UpdateDateTimeFieldCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::TextCommandArchive* super_;
    ::TSP::Reference* date_time_field_;
    ::TSP::Date* date_;
    int date_style_;
    int time_style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ApplyRubyTextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ApplyRubyTextCommandArchive) */ {
 public:
  inline ApplyRubyTextCommandArchive() : ApplyRubyTextCommandArchive(nullptr) {}
  ~ApplyRubyTextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ApplyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyRubyTextCommandArchive(const ApplyRubyTextCommandArchive& from);
  ApplyRubyTextCommandArchive(ApplyRubyTextCommandArchive&& from) noexcept
    : ApplyRubyTextCommandArchive() {
    *this = ::std::move(from);
  }

  inline ApplyRubyTextCommandArchive& operator=(const ApplyRubyTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyRubyTextCommandArchive& operator=(ApplyRubyTextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyRubyTextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyRubyTextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ApplyRubyTextCommandArchive*>(
               &_ApplyRubyTextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ApplyRubyTextCommandArchive& a, ApplyRubyTextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyRubyTextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyRubyTextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyRubyTextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyRubyTextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyRubyTextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyRubyTextCommandArchive& from) {
    ApplyRubyTextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyRubyTextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ApplyRubyTextCommandArchive";
  }
  protected:
  explicit ApplyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRubyTextFieldNumber = 5,
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 6,
    kSelectionRangeLocationFieldNumber = 3,
    kSelectionRangeLengthFieldNumber = 4,
  };
  // optional string ruby_text = 5;
  bool has_ruby_text() const;
  private:
  bool _internal_has_ruby_text() const;
  public:
  void clear_ruby_text();
  const std::string& ruby_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ruby_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ruby_text();
  PROTOBUF_NODISCARD std::string* release_ruby_text();
  void set_allocated_ruby_text(std::string* ruby_text);
  private:
  const std::string& _internal_ruby_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruby_text(const std::string& value);
  std::string* _internal_mutable_ruby_text();
  public:

  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 3;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 4;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.ApplyRubyTextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ruby_text_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveRubyTextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.RemoveRubyTextCommandArchive) */ {
 public:
  inline RemoveRubyTextCommandArchive() : RemoveRubyTextCommandArchive(nullptr) {}
  ~RemoveRubyTextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR RemoveRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRubyTextCommandArchive(const RemoveRubyTextCommandArchive& from);
  RemoveRubyTextCommandArchive(RemoveRubyTextCommandArchive&& from) noexcept
    : RemoveRubyTextCommandArchive() {
    *this = ::std::move(from);
  }

  inline RemoveRubyTextCommandArchive& operator=(const RemoveRubyTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRubyTextCommandArchive& operator=(RemoveRubyTextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRubyTextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRubyTextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const RemoveRubyTextCommandArchive*>(
               &_RemoveRubyTextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RemoveRubyTextCommandArchive& a, RemoveRubyTextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRubyTextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRubyTextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRubyTextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRubyTextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveRubyTextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveRubyTextCommandArchive& from) {
    RemoveRubyTextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRubyTextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.RemoveRubyTextCommandArchive";
  }
  protected:
  explicit RemoveRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
    kSelectionRangeLocationFieldNumber = 3,
    kSelectionRangeLengthFieldNumber = 4,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 selection_range_location = 3;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 4;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.RemoveRubyTextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ModifyRubyTextCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ModifyRubyTextCommandArchive) */ {
 public:
  inline ModifyRubyTextCommandArchive() : ModifyRubyTextCommandArchive(nullptr) {}
  ~ModifyRubyTextCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ModifyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyRubyTextCommandArchive(const ModifyRubyTextCommandArchive& from);
  ModifyRubyTextCommandArchive(ModifyRubyTextCommandArchive&& from) noexcept
    : ModifyRubyTextCommandArchive() {
    *this = ::std::move(from);
  }

  inline ModifyRubyTextCommandArchive& operator=(const ModifyRubyTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyRubyTextCommandArchive& operator=(ModifyRubyTextCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyRubyTextCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyRubyTextCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ModifyRubyTextCommandArchive*>(
               &_ModifyRubyTextCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ModifyRubyTextCommandArchive& a, ModifyRubyTextCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyRubyTextCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyRubyTextCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyRubyTextCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyRubyTextCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyRubyTextCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyRubyTextCommandArchive& from) {
    ModifyRubyTextCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyRubyTextCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ModifyRubyTextCommandArchive";
  }
  protected:
  explicit ModifyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRubyTextFieldNumber = 3,
    kBaseTextFieldNumber = 4,
    kSuperFieldNumber = 1,
    kRubyFieldFieldNumber = 2,
    kUndoTransactionFieldNumber = 5,
  };
  // optional string ruby_text = 3;
  bool has_ruby_text() const;
  private:
  bool _internal_has_ruby_text() const;
  public:
  void clear_ruby_text();
  const std::string& ruby_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ruby_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ruby_text();
  PROTOBUF_NODISCARD std::string* release_ruby_text();
  void set_allocated_ruby_text(std::string* ruby_text);
  private:
  const std::string& _internal_ruby_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruby_text(const std::string& value);
  std::string* _internal_mutable_ruby_text();
  public:

  // optional string base_text = 4;
  bool has_base_text() const;
  private:
  bool _internal_has_base_text() const;
  public:
  void clear_base_text();
  const std::string& base_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_text();
  PROTOBUF_NODISCARD std::string* release_base_text();
  void set_allocated_base_text(std::string* base_text);
  private:
  const std::string& _internal_base_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_text(const std::string& value);
  std::string* _internal_mutable_base_text();
  public:

  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference ruby_field = 2;
  bool has_ruby_field() const;
  private:
  bool _internal_has_ruby_field() const;
  public:
  void clear_ruby_field();
  const ::TSP::Reference& ruby_field() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_ruby_field();
  ::TSP::Reference* mutable_ruby_field();
  void set_allocated_ruby_field(::TSP::Reference* ruby_field);
  private:
  const ::TSP::Reference& _internal_ruby_field() const;
  ::TSP::Reference* _internal_mutable_ruby_field();
  public:
  void unsafe_arena_set_allocated_ruby_field(
      ::TSP::Reference* ruby_field);
  ::TSP::Reference* unsafe_arena_release_ruby_field();

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // @@protoc_insertion_point(class_scope:TSWP.ModifyRubyTextCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ruby_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_text_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* ruby_field_;
    ::TSWP::UndoTransaction* undo_transaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ModifyTOCSettingsBaseCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ModifyTOCSettingsBaseCommandArchive) */ {
 public:
  inline ModifyTOCSettingsBaseCommandArchive() : ModifyTOCSettingsBaseCommandArchive(nullptr) {}
  ~ModifyTOCSettingsBaseCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ModifyTOCSettingsBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyTOCSettingsBaseCommandArchive(const ModifyTOCSettingsBaseCommandArchive& from);
  ModifyTOCSettingsBaseCommandArchive(ModifyTOCSettingsBaseCommandArchive&& from) noexcept
    : ModifyTOCSettingsBaseCommandArchive() {
    *this = ::std::move(from);
  }

  inline ModifyTOCSettingsBaseCommandArchive& operator=(const ModifyTOCSettingsBaseCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyTOCSettingsBaseCommandArchive& operator=(ModifyTOCSettingsBaseCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyTOCSettingsBaseCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyTOCSettingsBaseCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ModifyTOCSettingsBaseCommandArchive*>(
               &_ModifyTOCSettingsBaseCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ModifyTOCSettingsBaseCommandArchive& a, ModifyTOCSettingsBaseCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyTOCSettingsBaseCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyTOCSettingsBaseCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyTOCSettingsBaseCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyTOCSettingsBaseCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyTOCSettingsBaseCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyTOCSettingsBaseCommandArchive& from) {
    ModifyTOCSettingsBaseCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyTOCSettingsBaseCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ModifyTOCSettingsBaseCommandArchive";
  }
  protected:
  explicit ModifyTOCSettingsBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kOldTocSettingsFieldNumber = 2,
    kNewTocSettingsFieldNumber = 3,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference old_toc_settings = 2;
  bool has_old_toc_settings() const;
  private:
  bool _internal_has_old_toc_settings() const;
  public:
  void clear_old_toc_settings();
  const ::TSP::Reference& old_toc_settings() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_old_toc_settings();
  ::TSP::Reference* mutable_old_toc_settings();
  void set_allocated_old_toc_settings(::TSP::Reference* old_toc_settings);
  private:
  const ::TSP::Reference& _internal_old_toc_settings() const;
  ::TSP::Reference* _internal_mutable_old_toc_settings();
  public:
  void unsafe_arena_set_allocated_old_toc_settings(
      ::TSP::Reference* old_toc_settings);
  ::TSP::Reference* unsafe_arena_release_old_toc_settings();

  // optional .TSP.Reference new_toc_settings = 3;
  bool has_new_toc_settings() const;
  private:
  bool _internal_has_new_toc_settings() const;
  public:
  void clear_new_toc_settings();
  const ::TSP::Reference& new_toc_settings() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_new_toc_settings();
  ::TSP::Reference* mutable_new_toc_settings();
  void set_allocated_new_toc_settings(::TSP::Reference* new_toc_settings);
  private:
  const ::TSP::Reference& _internal_new_toc_settings() const;
  ::TSP::Reference* _internal_mutable_new_toc_settings();
  public:
  void unsafe_arena_set_allocated_new_toc_settings(
      ::TSP::Reference* new_toc_settings);
  ::TSP::Reference* unsafe_arena_release_new_toc_settings();

  // @@protoc_insertion_point(class_scope:TSWP.ModifyTOCSettingsBaseCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* old_toc_settings_;
    ::TSP::Reference* new_toc_settings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ModifyTOCSettingsForTOCInfoCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive) */ {
 public:
  inline ModifyTOCSettingsForTOCInfoCommandArchive() : ModifyTOCSettingsForTOCInfoCommandArchive(nullptr) {}
  ~ModifyTOCSettingsForTOCInfoCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ModifyTOCSettingsForTOCInfoCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyTOCSettingsForTOCInfoCommandArchive(const ModifyTOCSettingsForTOCInfoCommandArchive& from);
  ModifyTOCSettingsForTOCInfoCommandArchive(ModifyTOCSettingsForTOCInfoCommandArchive&& from) noexcept
    : ModifyTOCSettingsForTOCInfoCommandArchive() {
    *this = ::std::move(from);
  }

  inline ModifyTOCSettingsForTOCInfoCommandArchive& operator=(const ModifyTOCSettingsForTOCInfoCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyTOCSettingsForTOCInfoCommandArchive& operator=(ModifyTOCSettingsForTOCInfoCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyTOCSettingsForTOCInfoCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyTOCSettingsForTOCInfoCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ModifyTOCSettingsForTOCInfoCommandArchive*>(
               &_ModifyTOCSettingsForTOCInfoCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ModifyTOCSettingsForTOCInfoCommandArchive& a, ModifyTOCSettingsForTOCInfoCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyTOCSettingsForTOCInfoCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyTOCSettingsForTOCInfoCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyTOCSettingsForTOCInfoCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyTOCSettingsForTOCInfoCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyTOCSettingsForTOCInfoCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyTOCSettingsForTOCInfoCommandArchive& from) {
    ModifyTOCSettingsForTOCInfoCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyTOCSettingsForTOCInfoCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ModifyTOCSettingsForTOCInfoCommandArchive";
  }
  protected:
  explicit ModifyTOCSettingsForTOCInfoCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kTocInfoFieldNumber = 2,
  };
  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::ModifyTOCSettingsBaseCommandArchive* release_super();
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super);
  private:
  const ::TSWP::ModifyTOCSettingsBaseCommandArchive& _internal_super() const;
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::ModifyTOCSettingsBaseCommandArchive* super);
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference toc_info = 2;
  bool has_toc_info() const;
  private:
  bool _internal_has_toc_info() const;
  public:
  void clear_toc_info();
  const ::TSP::Reference& toc_info() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_toc_info();
  ::TSP::Reference* mutable_toc_info();
  void set_allocated_toc_info(::TSP::Reference* toc_info);
  private:
  const ::TSP::Reference& _internal_toc_info() const;
  ::TSP::Reference* _internal_mutable_toc_info();
  public:
  void unsafe_arena_set_allocated_toc_info(
      ::TSP::Reference* toc_info);
  ::TSP::Reference* unsafe_arena_release_toc_info();

  // @@protoc_insertion_point(class_scope:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::ModifyTOCSettingsBaseCommandArchive* super_;
    ::TSP::Reference* toc_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ModifyTOCSettingsPresetForThemeCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive) */ {
 public:
  inline ModifyTOCSettingsPresetForThemeCommandArchive() : ModifyTOCSettingsPresetForThemeCommandArchive(nullptr) {}
  ~ModifyTOCSettingsPresetForThemeCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ModifyTOCSettingsPresetForThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyTOCSettingsPresetForThemeCommandArchive(const ModifyTOCSettingsPresetForThemeCommandArchive& from);
  ModifyTOCSettingsPresetForThemeCommandArchive(ModifyTOCSettingsPresetForThemeCommandArchive&& from) noexcept
    : ModifyTOCSettingsPresetForThemeCommandArchive() {
    *this = ::std::move(from);
  }

  inline ModifyTOCSettingsPresetForThemeCommandArchive& operator=(const ModifyTOCSettingsPresetForThemeCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyTOCSettingsPresetForThemeCommandArchive& operator=(ModifyTOCSettingsPresetForThemeCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyTOCSettingsPresetForThemeCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyTOCSettingsPresetForThemeCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ModifyTOCSettingsPresetForThemeCommandArchive*>(
               &_ModifyTOCSettingsPresetForThemeCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ModifyTOCSettingsPresetForThemeCommandArchive& a, ModifyTOCSettingsPresetForThemeCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyTOCSettingsPresetForThemeCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyTOCSettingsPresetForThemeCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyTOCSettingsPresetForThemeCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyTOCSettingsPresetForThemeCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyTOCSettingsPresetForThemeCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyTOCSettingsPresetForThemeCommandArchive& from) {
    ModifyTOCSettingsPresetForThemeCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyTOCSettingsPresetForThemeCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ModifyTOCSettingsPresetForThemeCommandArchive";
  }
  protected:
  explicit ModifyTOCSettingsPresetForThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kThemeFieldNumber = 2,
    kPresetIndexFieldNumber = 3,
  };
  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::ModifyTOCSettingsBaseCommandArchive* release_super();
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super);
  private:
  const ::TSWP::ModifyTOCSettingsBaseCommandArchive& _internal_super() const;
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::ModifyTOCSettingsBaseCommandArchive* super);
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference theme = 2;
  bool has_theme() const;
  private:
  bool _internal_has_theme() const;
  public:
  void clear_theme();
  const ::TSP::Reference& theme() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_theme();
  ::TSP::Reference* mutable_theme();
  void set_allocated_theme(::TSP::Reference* theme);
  private:
  const ::TSP::Reference& _internal_theme() const;
  ::TSP::Reference* _internal_mutable_theme();
  public:
  void unsafe_arena_set_allocated_theme(
      ::TSP::Reference* theme);
  ::TSP::Reference* unsafe_arena_release_theme();

  // optional uint32 preset_index = 3;
  bool has_preset_index() const;
  private:
  bool _internal_has_preset_index() const;
  public:
  void clear_preset_index();
  uint32_t preset_index() const;
  void set_preset_index(uint32_t value);
  private:
  uint32_t _internal_preset_index() const;
  void _internal_set_preset_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::ModifyTOCSettingsBaseCommandArchive* super_;
    ::TSP::Reference* theme_;
    uint32_t preset_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class AnchorAttachmentCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.AnchorAttachmentCommandArchive) */ {
 public:
  inline AnchorAttachmentCommandArchive() : AnchorAttachmentCommandArchive(nullptr) {}
  ~AnchorAttachmentCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR AnchorAttachmentCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnchorAttachmentCommandArchive(const AnchorAttachmentCommandArchive& from);
  AnchorAttachmentCommandArchive(AnchorAttachmentCommandArchive&& from) noexcept
    : AnchorAttachmentCommandArchive() {
    *this = ::std::move(from);
  }

  inline AnchorAttachmentCommandArchive& operator=(const AnchorAttachmentCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnchorAttachmentCommandArchive& operator=(AnchorAttachmentCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnchorAttachmentCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnchorAttachmentCommandArchive* internal_default_instance() {
    return reinterpret_cast<const AnchorAttachmentCommandArchive*>(
               &_AnchorAttachmentCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AnchorAttachmentCommandArchive& a, AnchorAttachmentCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(AnchorAttachmentCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnchorAttachmentCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnchorAttachmentCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnchorAttachmentCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnchorAttachmentCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnchorAttachmentCommandArchive& from) {
    AnchorAttachmentCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnchorAttachmentCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.AnchorAttachmentCommandArchive";
  }
  protected:
  explicit AnchorAttachmentCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kAttachmentFieldNumber = 3,
    kUndoTransactionFieldNumber = 8,
    kHOffsetTypeFieldNumber = 4,
    kHOffsetFieldNumber = 5,
    kVOffsetTypeFieldNumber = 6,
    kVOffsetFieldNumber = 7,
    kIsHtmlWrapFieldNumber = 9,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSP.Reference attachment = 3;
  bool has_attachment() const;
  private:
  bool _internal_has_attachment() const;
  public:
  void clear_attachment();
  const ::TSP::Reference& attachment() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_attachment();
  ::TSP::Reference* mutable_attachment();
  void set_allocated_attachment(::TSP::Reference* attachment);
  private:
  const ::TSP::Reference& _internal_attachment() const;
  ::TSP::Reference* _internal_mutable_attachment();
  public:
  void unsafe_arena_set_allocated_attachment(
      ::TSP::Reference* attachment);
  ::TSP::Reference* unsafe_arena_release_attachment();

  // optional .TSWP.UndoTransaction undo_transaction = 8;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 h_offset_type = 4;
  bool has_h_offset_type() const;
  private:
  bool _internal_has_h_offset_type() const;
  public:
  void clear_h_offset_type();
  uint32_t h_offset_type() const;
  void set_h_offset_type(uint32_t value);
  private:
  uint32_t _internal_h_offset_type() const;
  void _internal_set_h_offset_type(uint32_t value);
  public:

  // optional float h_offset = 5;
  bool has_h_offset() const;
  private:
  bool _internal_has_h_offset() const;
  public:
  void clear_h_offset();
  float h_offset() const;
  void set_h_offset(float value);
  private:
  float _internal_h_offset() const;
  void _internal_set_h_offset(float value);
  public:

  // optional uint32 v_offset_type = 6;
  bool has_v_offset_type() const;
  private:
  bool _internal_has_v_offset_type() const;
  public:
  void clear_v_offset_type();
  uint32_t v_offset_type() const;
  void set_v_offset_type(uint32_t value);
  private:
  uint32_t _internal_v_offset_type() const;
  void _internal_set_v_offset_type(uint32_t value);
  public:

  // optional float v_offset = 7;
  bool has_v_offset() const;
  private:
  bool _internal_has_v_offset() const;
  public:
  void clear_v_offset();
  float v_offset() const;
  void set_v_offset(float value);
  private:
  float _internal_v_offset() const;
  void _internal_set_v_offset(float value);
  public:

  // optional bool is_html_wrap = 9;
  bool has_is_html_wrap() const;
  private:
  bool _internal_has_is_html_wrap() const;
  public:
  void clear_is_html_wrap();
  bool is_html_wrap() const;
  void set_is_html_wrap(bool value);
  private:
  bool _internal_is_html_wrap() const;
  void _internal_set_is_html_wrap(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.AnchorAttachmentCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSP::Reference* attachment_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t h_offset_type_;
    float h_offset_;
    uint32_t v_offset_type_;
    float v_offset_;
    bool is_html_wrap_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class TextApplyThemeCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.TextApplyThemeCommandArchive) */ {
 public:
  inline TextApplyThemeCommandArchive() : TextApplyThemeCommandArchive(nullptr) {}
  ~TextApplyThemeCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR TextApplyThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextApplyThemeCommandArchive(const TextApplyThemeCommandArchive& from);
  TextApplyThemeCommandArchive(TextApplyThemeCommandArchive&& from) noexcept
    : TextApplyThemeCommandArchive() {
    *this = ::std::move(from);
  }

  inline TextApplyThemeCommandArchive& operator=(const TextApplyThemeCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextApplyThemeCommandArchive& operator=(TextApplyThemeCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextApplyThemeCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextApplyThemeCommandArchive* internal_default_instance() {
    return reinterpret_cast<const TextApplyThemeCommandArchive*>(
               &_TextApplyThemeCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TextApplyThemeCommandArchive& a, TextApplyThemeCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TextApplyThemeCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextApplyThemeCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextApplyThemeCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextApplyThemeCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextApplyThemeCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextApplyThemeCommandArchive& from) {
    TextApplyThemeCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextApplyThemeCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.TextApplyThemeCommandArchive";
  }
  protected:
  explicit TextApplyThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 6,
  };
  // optional .TSS.ApplyThemeChildCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::ApplyThemeChildCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::ApplyThemeChildCommandArchive* release_super();
  ::TSS::ApplyThemeChildCommandArchive* mutable_super();
  void set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super);
  private:
  const ::TSS::ApplyThemeChildCommandArchive& _internal_super() const;
  ::TSS::ApplyThemeChildCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::ApplyThemeChildCommandArchive* super);
  ::TSS::ApplyThemeChildCommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // @@protoc_insertion_point(class_scope:TSWP.TextApplyThemeCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::ApplyThemeChildCommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveColumnsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.MoveColumnsCommandArchive) */ {
 public:
  inline MoveColumnsCommandArchive() : MoveColumnsCommandArchive(nullptr) {}
  ~MoveColumnsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveColumnsCommandArchive(const MoveColumnsCommandArchive& from);
  MoveColumnsCommandArchive(MoveColumnsCommandArchive&& from) noexcept
    : MoveColumnsCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveColumnsCommandArchive& operator=(const MoveColumnsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveColumnsCommandArchive& operator=(MoveColumnsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveColumnsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveColumnsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveColumnsCommandArchive*>(
               &_MoveColumnsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MoveColumnsCommandArchive& a, MoveColumnsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveColumnsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveColumnsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveColumnsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveColumnsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveColumnsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveColumnsCommandArchive& from) {
    MoveColumnsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveColumnsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.MoveColumnsCommandArchive";
  }
  protected:
  explicit MoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 6,
    kSrcIndexFieldNumber = 3,
    kDstIndexFieldNumber = 4,
    kCountFieldNumber = 5,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 src_index = 3;
  bool has_src_index() const;
  private:
  bool _internal_has_src_index() const;
  public:
  void clear_src_index();
  uint32_t src_index() const;
  void set_src_index(uint32_t value);
  private:
  uint32_t _internal_src_index() const;
  void _internal_set_src_index(uint32_t value);
  public:

  // optional uint32 dst_index = 4;
  bool has_dst_index() const;
  private:
  bool _internal_has_dst_index() const;
  public:
  void clear_dst_index();
  uint32_t dst_index() const;
  void set_dst_index(uint32_t value);
  private:
  uint32_t _internal_dst_index() const;
  void _internal_set_dst_index(uint32_t value);
  public:

  // optional uint32 count = 5;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.MoveColumnsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t src_index_;
    uint32_t dst_index_;
    uint32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveRowsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.MoveRowsCommandArchive) */ {
 public:
  inline MoveRowsCommandArchive() : MoveRowsCommandArchive(nullptr) {}
  ~MoveRowsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveRowsCommandArchive(const MoveRowsCommandArchive& from);
  MoveRowsCommandArchive(MoveRowsCommandArchive&& from) noexcept
    : MoveRowsCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveRowsCommandArchive& operator=(const MoveRowsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveRowsCommandArchive& operator=(MoveRowsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveRowsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveRowsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveRowsCommandArchive*>(
               &_MoveRowsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MoveRowsCommandArchive& a, MoveRowsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveRowsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveRowsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveRowsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveRowsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveRowsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveRowsCommandArchive& from) {
    MoveRowsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveRowsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.MoveRowsCommandArchive";
  }
  protected:
  explicit MoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
    kUndoTransactionFieldNumber = 6,
    kSrcIndexFieldNumber = 3,
    kDstIndexFieldNumber = 4,
    kCountFieldNumber = 5,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 src_index = 3;
  bool has_src_index() const;
  private:
  bool _internal_has_src_index() const;
  public:
  void clear_src_index();
  uint32_t src_index() const;
  void set_src_index(uint32_t value);
  private:
  uint32_t _internal_src_index() const;
  void _internal_set_src_index(uint32_t value);
  public:

  // optional uint32 dst_index = 4;
  bool has_dst_index() const;
  private:
  bool _internal_has_dst_index() const;
  public:
  void clear_dst_index();
  uint32_t dst_index() const;
  void set_dst_index(uint32_t value);
  private:
  uint32_t _internal_dst_index() const;
  void _internal_set_dst_index(uint32_t value);
  public:

  // optional uint32 count = 5;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.MoveRowsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t src_index_;
    uint32_t dst_index_;
    uint32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapeApplyPresetCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ShapeApplyPresetCommandArchive) */ {
 public:
  inline ShapeApplyPresetCommandArchive() : ShapeApplyPresetCommandArchive(nullptr) {}
  ~ShapeApplyPresetCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ShapeApplyPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeApplyPresetCommandArchive(const ShapeApplyPresetCommandArchive& from);
  ShapeApplyPresetCommandArchive(ShapeApplyPresetCommandArchive&& from) noexcept
    : ShapeApplyPresetCommandArchive() {
    *this = ::std::move(from);
  }

  inline ShapeApplyPresetCommandArchive& operator=(const ShapeApplyPresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeApplyPresetCommandArchive& operator=(ShapeApplyPresetCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeApplyPresetCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeApplyPresetCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ShapeApplyPresetCommandArchive*>(
               &_ShapeApplyPresetCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ShapeApplyPresetCommandArchive& a, ShapeApplyPresetCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeApplyPresetCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeApplyPresetCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeApplyPresetCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeApplyPresetCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapeApplyPresetCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapeApplyPresetCommandArchive& from) {
    ShapeApplyPresetCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeApplyPresetCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ShapeApplyPresetCommandArchive";
  }
  protected:
  explicit ShapeApplyPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSD.ShapeApplyPresetCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::ShapeApplyPresetCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::ShapeApplyPresetCommandArchive* release_super();
  ::TSD::ShapeApplyPresetCommandArchive* mutable_super();
  void set_allocated_super(::TSD::ShapeApplyPresetCommandArchive* super);
  private:
  const ::TSD::ShapeApplyPresetCommandArchive& _internal_super() const;
  ::TSD::ShapeApplyPresetCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::ShapeApplyPresetCommandArchive* super);
  ::TSD::ShapeApplyPresetCommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSWP.ShapeApplyPresetCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::ShapeApplyPresetCommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapePasteStyleCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.ShapePasteStyleCommandArchive) */ {
 public:
  inline ShapePasteStyleCommandArchive() : ShapePasteStyleCommandArchive(nullptr) {}
  ~ShapePasteStyleCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ShapePasteStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapePasteStyleCommandArchive(const ShapePasteStyleCommandArchive& from);
  ShapePasteStyleCommandArchive(ShapePasteStyleCommandArchive&& from) noexcept
    : ShapePasteStyleCommandArchive() {
    *this = ::std::move(from);
  }

  inline ShapePasteStyleCommandArchive& operator=(const ShapePasteStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapePasteStyleCommandArchive& operator=(ShapePasteStyleCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapePasteStyleCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapePasteStyleCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ShapePasteStyleCommandArchive*>(
               &_ShapePasteStyleCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ShapePasteStyleCommandArchive& a, ShapePasteStyleCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapePasteStyleCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapePasteStyleCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapePasteStyleCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapePasteStyleCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapePasteStyleCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapePasteStyleCommandArchive& from) {
    ShapePasteStyleCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapePasteStyleCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.ShapePasteStyleCommandArchive";
  }
  protected:
  explicit ShapePasteStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kParagraphStyleFieldNumber = 2,
    kListStyleFieldNumber = 3,
    kCharacterStyleFieldNumber = 4,
  };
  // required .TSD.PasteStyleCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::PasteStyleCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::PasteStyleCommandArchive* release_super();
  ::TSD::PasteStyleCommandArchive* mutable_super();
  void set_allocated_super(::TSD::PasteStyleCommandArchive* super);
  private:
  const ::TSD::PasteStyleCommandArchive& _internal_super() const;
  ::TSD::PasteStyleCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::PasteStyleCommandArchive* super);
  ::TSD::PasteStyleCommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference paragraph_style = 2;
  bool has_paragraph_style() const;
  private:
  bool _internal_has_paragraph_style() const;
  public:
  void clear_paragraph_style();
  const ::TSP::Reference& paragraph_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_paragraph_style();
  ::TSP::Reference* mutable_paragraph_style();
  void set_allocated_paragraph_style(::TSP::Reference* paragraph_style);
  private:
  const ::TSP::Reference& _internal_paragraph_style() const;
  ::TSP::Reference* _internal_mutable_paragraph_style();
  public:
  void unsafe_arena_set_allocated_paragraph_style(
      ::TSP::Reference* paragraph_style);
  ::TSP::Reference* unsafe_arena_release_paragraph_style();

  // optional .TSP.Reference list_style = 3;
  bool has_list_style() const;
  private:
  bool _internal_has_list_style() const;
  public:
  void clear_list_style();
  const ::TSP::Reference& list_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_list_style();
  ::TSP::Reference* mutable_list_style();
  void set_allocated_list_style(::TSP::Reference* list_style);
  private:
  const ::TSP::Reference& _internal_list_style() const;
  ::TSP::Reference* _internal_mutable_list_style();
  public:
  void unsafe_arena_set_allocated_list_style(
      ::TSP::Reference* list_style);
  ::TSP::Reference* unsafe_arena_release_list_style();

  // optional .TSP.Reference character_style = 4;
  bool has_character_style() const;
  private:
  bool _internal_has_character_style() const;
  public:
  void clear_character_style();
  const ::TSP::Reference& character_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_character_style();
  ::TSP::Reference* mutable_character_style();
  void set_allocated_character_style(::TSP::Reference* character_style);
  private:
  const ::TSP::Reference& _internal_character_style() const;
  ::TSP::Reference* _internal_mutable_character_style();
  public:
  void unsafe_arena_set_allocated_character_style(
      ::TSP::Reference* character_style);
  ::TSP::Reference* unsafe_arena_release_character_style();

  // @@protoc_insertion_point(class_scope:TSWP.ShapePasteStyleCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::PasteStyleCommandArchive* super_;
    ::TSP::Reference* paragraph_style_;
    ::TSP::Reference* list_style_;
    ::TSP::Reference* character_style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleBaseCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.StyleBaseCommandArchive) */ {
 public:
  inline StyleBaseCommandArchive() : StyleBaseCommandArchive(nullptr) {}
  ~StyleBaseCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleBaseCommandArchive(const StyleBaseCommandArchive& from);
  StyleBaseCommandArchive(StyleBaseCommandArchive&& from) noexcept
    : StyleBaseCommandArchive() {
    *this = ::std::move(from);
  }

  inline StyleBaseCommandArchive& operator=(const StyleBaseCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleBaseCommandArchive& operator=(StyleBaseCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleBaseCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleBaseCommandArchive* internal_default_instance() {
    return reinterpret_cast<const StyleBaseCommandArchive*>(
               &_StyleBaseCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(StyleBaseCommandArchive& a, StyleBaseCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleBaseCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleBaseCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleBaseCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleBaseCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleBaseCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleBaseCommandArchive& from) {
    StyleBaseCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleBaseCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.StyleBaseCommandArchive";
  }
  protected:
  explicit StyleBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kThemeFieldNumber = 2,
    kStyleFieldNumber = 3,
  };
  // optional .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference theme = 2;
  bool has_theme() const;
  private:
  bool _internal_has_theme() const;
  public:
  void clear_theme();
  const ::TSP::Reference& theme() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_theme();
  ::TSP::Reference* mutable_theme();
  void set_allocated_theme(::TSP::Reference* theme);
  private:
  const ::TSP::Reference& _internal_theme() const;
  ::TSP::Reference* _internal_mutable_theme();
  public:
  void unsafe_arena_set_allocated_theme(
      ::TSP::Reference* theme);
  ::TSP::Reference* unsafe_arena_release_theme();

  // optional .TSP.Reference style = 3;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::TSP::Reference& style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_style();
  ::TSP::Reference* mutable_style();
  void set_allocated_style(::TSP::Reference* style);
  private:
  const ::TSP::Reference& _internal_style() const;
  ::TSP::Reference* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::TSP::Reference* style);
  ::TSP::Reference* unsafe_arena_release_style();

  // @@protoc_insertion_point(class_scope:TSWP.StyleBaseCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* theme_;
    ::TSP::Reference* style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleCreateCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.StyleCreateCommandArchive) */ {
 public:
  inline StyleCreateCommandArchive() : StyleCreateCommandArchive(nullptr) {}
  ~StyleCreateCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleCreateCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleCreateCommandArchive(const StyleCreateCommandArchive& from);
  StyleCreateCommandArchive(StyleCreateCommandArchive&& from) noexcept
    : StyleCreateCommandArchive() {
    *this = ::std::move(from);
  }

  inline StyleCreateCommandArchive& operator=(const StyleCreateCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleCreateCommandArchive& operator=(StyleCreateCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleCreateCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleCreateCommandArchive* internal_default_instance() {
    return reinterpret_cast<const StyleCreateCommandArchive*>(
               &_StyleCreateCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(StyleCreateCommandArchive& a, StyleCreateCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleCreateCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleCreateCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleCreateCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleCreateCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleCreateCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleCreateCommandArchive& from) {
    StyleCreateCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleCreateCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.StyleCreateCommandArchive";
  }
  protected:
  explicit StyleCreateCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kPresetIndexFieldNumber = 2,
  };
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::StyleBaseCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::StyleBaseCommandArchive* release_super();
  ::TSWP::StyleBaseCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);
  private:
  const ::TSWP::StyleBaseCommandArchive& _internal_super() const;
  ::TSWP::StyleBaseCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::StyleBaseCommandArchive* super);
  ::TSWP::StyleBaseCommandArchive* unsafe_arena_release_super();

  // optional uint32 preset_index = 2;
  bool has_preset_index() const;
  private:
  bool _internal_has_preset_index() const;
  public:
  void clear_preset_index();
  uint32_t preset_index() const;
  void set_preset_index(uint32_t value);
  private:
  uint32_t _internal_preset_index() const;
  void _internal_set_preset_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.StyleCreateCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::StyleBaseCommandArchive* super_;
    uint32_t preset_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleRenameCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.StyleRenameCommandArchive) */ {
 public:
  inline StyleRenameCommandArchive() : StyleRenameCommandArchive(nullptr) {}
  ~StyleRenameCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleRenameCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleRenameCommandArchive(const StyleRenameCommandArchive& from);
  StyleRenameCommandArchive(StyleRenameCommandArchive&& from) noexcept
    : StyleRenameCommandArchive() {
    *this = ::std::move(from);
  }

  inline StyleRenameCommandArchive& operator=(const StyleRenameCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleRenameCommandArchive& operator=(StyleRenameCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleRenameCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleRenameCommandArchive* internal_default_instance() {
    return reinterpret_cast<const StyleRenameCommandArchive*>(
               &_StyleRenameCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(StyleRenameCommandArchive& a, StyleRenameCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleRenameCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleRenameCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleRenameCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleRenameCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleRenameCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleRenameCommandArchive& from) {
    StyleRenameCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleRenameCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.StyleRenameCommandArchive";
  }
  protected:
  explicit StyleRenameCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatedNameFieldNumber = 2,
    kOldNameFieldNumber = 3,
    kSuperFieldNumber = 1,
  };
  // optional string updated_name = 2;
  bool has_updated_name() const;
  private:
  bool _internal_has_updated_name() const;
  public:
  void clear_updated_name();
  const std::string& updated_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_name();
  PROTOBUF_NODISCARD std::string* release_updated_name();
  void set_allocated_updated_name(std::string* updated_name);
  private:
  const std::string& _internal_updated_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_name(const std::string& value);
  std::string* _internal_mutable_updated_name();
  public:

  // optional string old_name = 3;
  bool has_old_name() const;
  private:
  bool _internal_has_old_name() const;
  public:
  void clear_old_name();
  const std::string& old_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_name();
  PROTOBUF_NODISCARD std::string* release_old_name();
  void set_allocated_old_name(std::string* old_name);
  private:
  const std::string& _internal_old_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_name(const std::string& value);
  std::string* _internal_mutable_old_name();
  public:

  // optional .TSWP.StyleBaseCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::StyleBaseCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::StyleBaseCommandArchive* release_super();
  ::TSWP::StyleBaseCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);
  private:
  const ::TSWP::StyleBaseCommandArchive& _internal_super() const;
  ::TSWP::StyleBaseCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::StyleBaseCommandArchive* super);
  ::TSWP::StyleBaseCommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSWP.StyleRenameCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_name_;
    ::TSWP::StyleBaseCommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleUpdateCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.StyleUpdateCommandArchive) */ {
 public:
  inline StyleUpdateCommandArchive() : StyleUpdateCommandArchive(nullptr) {}
  ~StyleUpdateCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleUpdateCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleUpdateCommandArchive(const StyleUpdateCommandArchive& from);
  StyleUpdateCommandArchive(StyleUpdateCommandArchive&& from) noexcept
    : StyleUpdateCommandArchive() {
    *this = ::std::move(from);
  }

  inline StyleUpdateCommandArchive& operator=(const StyleUpdateCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleUpdateCommandArchive& operator=(StyleUpdateCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleUpdateCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleUpdateCommandArchive* internal_default_instance() {
    return reinterpret_cast<const StyleUpdateCommandArchive*>(
               &_StyleUpdateCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(StyleUpdateCommandArchive& a, StyleUpdateCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleUpdateCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleUpdateCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleUpdateCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleUpdateCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleUpdateCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleUpdateCommandArchive& from) {
    StyleUpdateCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleUpdateCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.StyleUpdateCommandArchive";
  }
  protected:
  explicit StyleUpdateCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kOriginalStyleFieldNumber = 2,
    kUpdatedStyleFieldNumber = 3,
  };
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::StyleBaseCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::StyleBaseCommandArchive* release_super();
  ::TSWP::StyleBaseCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);
  private:
  const ::TSWP::StyleBaseCommandArchive& _internal_super() const;
  ::TSWP::StyleBaseCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::StyleBaseCommandArchive* super);
  ::TSWP::StyleBaseCommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference original_style = 2;
  bool has_original_style() const;
  private:
  bool _internal_has_original_style() const;
  public:
  void clear_original_style();
  const ::TSP::Reference& original_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_original_style();
  ::TSP::Reference* mutable_original_style();
  void set_allocated_original_style(::TSP::Reference* original_style);
  private:
  const ::TSP::Reference& _internal_original_style() const;
  ::TSP::Reference* _internal_mutable_original_style();
  public:
  void unsafe_arena_set_allocated_original_style(
      ::TSP::Reference* original_style);
  ::TSP::Reference* unsafe_arena_release_original_style();

  // optional .TSP.Reference updated_style = 3;
  bool has_updated_style() const;
  private:
  bool _internal_has_updated_style() const;
  public:
  void clear_updated_style();
  const ::TSP::Reference& updated_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_updated_style();
  ::TSP::Reference* mutable_updated_style();
  void set_allocated_updated_style(::TSP::Reference* updated_style);
  private:
  const ::TSP::Reference& _internal_updated_style() const;
  ::TSP::Reference* _internal_mutable_updated_style();
  public:
  void unsafe_arena_set_allocated_updated_style(
      ::TSP::Reference* updated_style);
  ::TSP::Reference* unsafe_arena_release_updated_style();

  // @@protoc_insertion_point(class_scope:TSWP.StyleUpdateCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::StyleBaseCommandArchive* super_;
    ::TSP::Reference* original_style_;
    ::TSP::Reference* updated_style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleDeleteCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.StyleDeleteCommandArchive) */ {
 public:
  inline StyleDeleteCommandArchive() : StyleDeleteCommandArchive(nullptr) {}
  ~StyleDeleteCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleDeleteCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleDeleteCommandArchive(const StyleDeleteCommandArchive& from);
  StyleDeleteCommandArchive(StyleDeleteCommandArchive&& from) noexcept
    : StyleDeleteCommandArchive() {
    *this = ::std::move(from);
  }

  inline StyleDeleteCommandArchive& operator=(const StyleDeleteCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleDeleteCommandArchive& operator=(StyleDeleteCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleDeleteCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleDeleteCommandArchive* internal_default_instance() {
    return reinterpret_cast<const StyleDeleteCommandArchive*>(
               &_StyleDeleteCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(StyleDeleteCommandArchive& a, StyleDeleteCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleDeleteCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleDeleteCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleDeleteCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleDeleteCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleDeleteCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleDeleteCommandArchive& from) {
    StyleDeleteCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleDeleteCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.StyleDeleteCommandArchive";
  }
  protected:
  explicit StyleDeleteCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kOldPresetIndexFieldNumber = 2,
  };
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::StyleBaseCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::StyleBaseCommandArchive* release_super();
  ::TSWP::StyleBaseCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);
  private:
  const ::TSWP::StyleBaseCommandArchive& _internal_super() const;
  ::TSWP::StyleBaseCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::StyleBaseCommandArchive* super);
  ::TSWP::StyleBaseCommandArchive* unsafe_arena_release_super();

  // optional uint32 old_preset_index = 2;
  bool has_old_preset_index() const;
  private:
  bool _internal_has_old_preset_index() const;
  public:
  void clear_old_preset_index();
  uint32_t old_preset_index() const;
  void set_old_preset_index(uint32_t value);
  private:
  uint32_t _internal_old_preset_index() const;
  void _internal_set_old_preset_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.StyleDeleteCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::StyleBaseCommandArchive* super_;
    uint32_t old_preset_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleReorderCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.StyleReorderCommandArchive) */ {
 public:
  inline StyleReorderCommandArchive() : StyleReorderCommandArchive(nullptr) {}
  ~StyleReorderCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleReorderCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleReorderCommandArchive(const StyleReorderCommandArchive& from);
  StyleReorderCommandArchive(StyleReorderCommandArchive&& from) noexcept
    : StyleReorderCommandArchive() {
    *this = ::std::move(from);
  }

  inline StyleReorderCommandArchive& operator=(const StyleReorderCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleReorderCommandArchive& operator=(StyleReorderCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleReorderCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleReorderCommandArchive* internal_default_instance() {
    return reinterpret_cast<const StyleReorderCommandArchive*>(
               &_StyleReorderCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(StyleReorderCommandArchive& a, StyleReorderCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleReorderCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleReorderCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleReorderCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleReorderCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleReorderCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleReorderCommandArchive& from) {
    StyleReorderCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleReorderCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.StyleReorderCommandArchive";
  }
  protected:
  explicit StyleReorderCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kOldPresetIndexFieldNumber = 2,
    kNewPresetIndexFieldNumber = 3,
  };
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::StyleBaseCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::StyleBaseCommandArchive* release_super();
  ::TSWP::StyleBaseCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);
  private:
  const ::TSWP::StyleBaseCommandArchive& _internal_super() const;
  ::TSWP::StyleBaseCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::StyleBaseCommandArchive* super);
  ::TSWP::StyleBaseCommandArchive* unsafe_arena_release_super();

  // optional uint32 old_preset_index = 2;
  bool has_old_preset_index() const;
  private:
  bool _internal_has_old_preset_index() const;
  public:
  void clear_old_preset_index();
  uint32_t old_preset_index() const;
  void set_old_preset_index(uint32_t value);
  private:
  uint32_t _internal_old_preset_index() const;
  void _internal_set_old_preset_index(uint32_t value);
  public:

  // optional uint32 new_preset_index = 3;
  bool has_new_preset_index() const;
  private:
  bool _internal_has_new_preset_index() const;
  public:
  void clear_new_preset_index();
  uint32_t new_preset_index() const;
  void set_new_preset_index(uint32_t value);
  private:
  uint32_t _internal_new_preset_index() const;
  void _internal_set_new_preset_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSWP.StyleReorderCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::StyleBaseCommandArchive* super_;
    uint32_t old_preset_index_;
    uint32_t new_preset_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleUpdatePropertyMapCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSWP.StyleUpdatePropertyMapCommandArchive) */ {
 public:
  inline StyleUpdatePropertyMapCommandArchive() : StyleUpdatePropertyMapCommandArchive(nullptr) {}
  ~StyleUpdatePropertyMapCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleUpdatePropertyMapCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleUpdatePropertyMapCommandArchive(const StyleUpdatePropertyMapCommandArchive& from);
  StyleUpdatePropertyMapCommandArchive(StyleUpdatePropertyMapCommandArchive&& from) noexcept
    : StyleUpdatePropertyMapCommandArchive() {
    *this = ::std::move(from);
  }

  inline StyleUpdatePropertyMapCommandArchive& operator=(const StyleUpdatePropertyMapCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleUpdatePropertyMapCommandArchive& operator=(StyleUpdatePropertyMapCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleUpdatePropertyMapCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleUpdatePropertyMapCommandArchive* internal_default_instance() {
    return reinterpret_cast<const StyleUpdatePropertyMapCommandArchive*>(
               &_StyleUpdatePropertyMapCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(StyleUpdatePropertyMapCommandArchive& a, StyleUpdatePropertyMapCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleUpdatePropertyMapCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleUpdatePropertyMapCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleUpdatePropertyMapCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleUpdatePropertyMapCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleUpdatePropertyMapCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleUpdatePropertyMapCommandArchive& from) {
    StyleUpdatePropertyMapCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleUpdatePropertyMapCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSWP.StyleUpdatePropertyMapCommandArchive";
  }
  protected:
  explicit StyleUpdatePropertyMapCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleUpdatePropertyMapCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleUpdatePropertyMapCommandArchive* release_super();
  ::TSS::StyleUpdatePropertyMapCommandArchive* mutable_super();
  void set_allocated_super(::TSS::StyleUpdatePropertyMapCommandArchive* super);
  private:
  const ::TSS::StyleUpdatePropertyMapCommandArchive& _internal_super() const;
  ::TSS::StyleUpdatePropertyMapCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleUpdatePropertyMapCommandArchive* super);
  ::TSS::StyleUpdatePropertyMapCommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSWP.StyleUpdatePropertyMapCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleUpdatePropertyMapCommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSWPCommandArchives_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DummyCommandArchive

// required uint32 foo = 1;
inline bool DummyCommandArchive::_internal_has_foo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DummyCommandArchive::has_foo() const {
  return _internal_has_foo();
}
inline void DummyCommandArchive::clear_foo() {
  _impl_.foo_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t DummyCommandArchive::_internal_foo() const {
  return _impl_.foo_;
}
inline uint32_t DummyCommandArchive::foo() const {
  // @@protoc_insertion_point(field_get:TSWP.DummyCommandArchive.foo)
  return _internal_foo();
}
inline void DummyCommandArchive::_internal_set_foo(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.foo_ = value;
}
inline void DummyCommandArchive::set_foo(uint32_t value) {
  _internal_set_foo(value);
  // @@protoc_insertion_point(field_set:TSWP.DummyCommandArchive.foo)
}

// -------------------------------------------------------------------

// TextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool TextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool TextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& TextCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& TextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.super)
  return _internal_super();
}
inline void TextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.TextCommandArchive.super)
}
inline ::TSK::CommandArchive* TextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* TextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.TextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* TextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* TextCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.TextCommandArchive.super)
  return _msg;
}
inline void TextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.TextCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool TextCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool TextCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& TextCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TextCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.storage)
  return _internal_storage();
}
inline void TextCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.TextCommandArchive.storage)
}
inline ::TSP::Reference* TextCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TextCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.TextCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TextCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* TextCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.TextCommandArchive.storage)
  return _msg;
}
inline void TextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.TextCommandArchive.storage)
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool TextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool TextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& TextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& TextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void TextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.TextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* TextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* TextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.TextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* TextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* TextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.TextCommandArchive.undo_transaction)
  return _msg;
}
inline void TextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.TextCommandArchive.undo_transaction)
}

// optional uint32 restore_range_location = 4;
inline bool TextCommandArchive::_internal_has_restore_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TextCommandArchive::has_restore_range_location() const {
  return _internal_has_restore_range_location();
}
inline void TextCommandArchive::clear_restore_range_location() {
  _impl_.restore_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TextCommandArchive::_internal_restore_range_location() const {
  return _impl_.restore_range_location_;
}
inline uint32_t TextCommandArchive::restore_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.restore_range_location)
  return _internal_restore_range_location();
}
inline void TextCommandArchive::_internal_set_restore_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.restore_range_location_ = value;
}
inline void TextCommandArchive::set_restore_range_location(uint32_t value) {
  _internal_set_restore_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.TextCommandArchive.restore_range_location)
}

// optional uint32 restore_range_length = 5;
inline bool TextCommandArchive::_internal_has_restore_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TextCommandArchive::has_restore_range_length() const {
  return _internal_has_restore_range_length();
}
inline void TextCommandArchive::clear_restore_range_length() {
  _impl_.restore_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TextCommandArchive::_internal_restore_range_length() const {
  return _impl_.restore_range_length_;
}
inline uint32_t TextCommandArchive::restore_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.restore_range_length)
  return _internal_restore_range_length();
}
inline void TextCommandArchive::_internal_set_restore_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.restore_range_length_ = value;
}
inline void TextCommandArchive::set_restore_range_length(uint32_t value) {
  _internal_set_restore_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.TextCommandArchive.restore_range_length)
}

// optional uint32 redo_restore_range_location = 6;
inline bool TextCommandArchive::_internal_has_redo_restore_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TextCommandArchive::has_redo_restore_range_location() const {
  return _internal_has_redo_restore_range_location();
}
inline void TextCommandArchive::clear_redo_restore_range_location() {
  _impl_.redo_restore_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TextCommandArchive::_internal_redo_restore_range_location() const {
  return _impl_.redo_restore_range_location_;
}
inline uint32_t TextCommandArchive::redo_restore_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.redo_restore_range_location)
  return _internal_redo_restore_range_location();
}
inline void TextCommandArchive::_internal_set_redo_restore_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.redo_restore_range_location_ = value;
}
inline void TextCommandArchive::set_redo_restore_range_location(uint32_t value) {
  _internal_set_redo_restore_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.TextCommandArchive.redo_restore_range_location)
}

// optional uint32 redo_restore_range_length = 7;
inline bool TextCommandArchive::_internal_has_redo_restore_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TextCommandArchive::has_redo_restore_range_length() const {
  return _internal_has_redo_restore_range_length();
}
inline void TextCommandArchive::clear_redo_restore_range_length() {
  _impl_.redo_restore_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TextCommandArchive::_internal_redo_restore_range_length() const {
  return _impl_.redo_restore_range_length_;
}
inline uint32_t TextCommandArchive::redo_restore_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.redo_restore_range_length)
  return _internal_redo_restore_range_length();
}
inline void TextCommandArchive::_internal_set_redo_restore_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.redo_restore_range_length_ = value;
}
inline void TextCommandArchive::set_redo_restore_range_length(uint32_t value) {
  _internal_set_redo_restore_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.TextCommandArchive.redo_restore_range_length)
}

// optional uint32 text_command_flags = 9;
inline bool TextCommandArchive::_internal_has_text_command_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TextCommandArchive::has_text_command_flags() const {
  return _internal_has_text_command_flags();
}
inline void TextCommandArchive::clear_text_command_flags() {
  _impl_.text_command_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TextCommandArchive::_internal_text_command_flags() const {
  return _impl_.text_command_flags_;
}
inline uint32_t TextCommandArchive::text_command_flags() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.text_command_flags)
  return _internal_text_command_flags();
}
inline void TextCommandArchive::_internal_set_text_command_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.text_command_flags_ = value;
}
inline void TextCommandArchive::set_text_command_flags(uint32_t value) {
  _internal_set_text_command_flags(value);
  // @@protoc_insertion_point(field_set:TSWP.TextCommandArchive.text_command_flags)
}

// optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
inline bool TextCommandArchive::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TextCommandArchive::has_kind() const {
  return _internal_has_kind();
}
inline void TextCommandArchive::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::TSWP::TextCommandArchive_Kind TextCommandArchive::_internal_kind() const {
  return static_cast< ::TSWP::TextCommandArchive_Kind >(_impl_.kind_);
}
inline ::TSWP::TextCommandArchive_Kind TextCommandArchive::kind() const {
  // @@protoc_insertion_point(field_get:TSWP.TextCommandArchive.kind)
  return _internal_kind();
}
inline void TextCommandArchive::_internal_set_kind(::TSWP::TextCommandArchive_Kind value) {
  assert(::TSWP::TextCommandArchive_Kind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.kind_ = value;
}
inline void TextCommandArchive::set_kind(::TSWP::TextCommandArchive_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:TSWP.TextCommandArchive.kind)
}

// -------------------------------------------------------------------

// ReplaceAllTextCommandArchive

// optional .TSK.ReplaceAllChildCommandArchive super = 1;
inline bool ReplaceAllTextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ReplaceAllTextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::ReplaceAllChildCommandArchive& ReplaceAllTextCommandArchive::_internal_super() const {
  const ::TSK::ReplaceAllChildCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::ReplaceAllChildCommandArchive&>(
      ::TSK::_ReplaceAllChildCommandArchive_default_instance_);
}
inline const ::TSK::ReplaceAllChildCommandArchive& ReplaceAllTextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ReplaceAllTextCommandArchive.super)
  return _internal_super();
}
inline void ReplaceAllTextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::ReplaceAllChildCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ReplaceAllTextCommandArchive.super)
}
inline ::TSK::ReplaceAllChildCommandArchive* ReplaceAllTextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::ReplaceAllChildCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::ReplaceAllChildCommandArchive* ReplaceAllTextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ReplaceAllTextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::ReplaceAllChildCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::ReplaceAllChildCommandArchive* ReplaceAllTextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::ReplaceAllChildCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::ReplaceAllChildCommandArchive* ReplaceAllTextCommandArchive::mutable_super() {
  ::TSK::ReplaceAllChildCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ReplaceAllTextCommandArchive.super)
  return _msg;
}
inline void ReplaceAllTextCommandArchive::set_allocated_super(::TSK::ReplaceAllChildCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ReplaceAllTextCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool ReplaceAllTextCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool ReplaceAllTextCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& ReplaceAllTextCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ReplaceAllTextCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.ReplaceAllTextCommandArchive.storage)
  return _internal_storage();
}
inline void ReplaceAllTextCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ReplaceAllTextCommandArchive.storage)
}
inline ::TSP::Reference* ReplaceAllTextCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ReplaceAllTextCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.ReplaceAllTextCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ReplaceAllTextCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* ReplaceAllTextCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.ReplaceAllTextCommandArchive.storage)
  return _msg;
}
inline void ReplaceAllTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ReplaceAllTextCommandArchive.storage)
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool ReplaceAllTextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ReplaceAllTextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ReplaceAllTextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ReplaceAllTextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.ReplaceAllTextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ReplaceAllTextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ReplaceAllTextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ReplaceAllTextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ReplaceAllTextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.ReplaceAllTextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ReplaceAllTextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ReplaceAllTextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.ReplaceAllTextCommandArchive.undo_transaction)
  return _msg;
}
inline void ReplaceAllTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ReplaceAllTextCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// FormatTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool FormatTextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool FormatTextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& FormatTextCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& FormatTextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.FormatTextCommandArchive.super)
  return _internal_super();
}
inline void FormatTextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.FormatTextCommandArchive.super)
}
inline ::TSK::CommandArchive* FormatTextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* FormatTextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.FormatTextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* FormatTextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* FormatTextCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.FormatTextCommandArchive.super)
  return _msg;
}
inline void FormatTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.FormatTextCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool FormatTextCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool FormatTextCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& FormatTextCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& FormatTextCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.FormatTextCommandArchive.storage)
  return _internal_storage();
}
inline void FormatTextCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.FormatTextCommandArchive.storage)
}
inline ::TSP::Reference* FormatTextCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* FormatTextCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.FormatTextCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* FormatTextCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* FormatTextCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.FormatTextCommandArchive.storage)
  return _msg;
}
inline void FormatTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.FormatTextCommandArchive.storage)
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool FormatTextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool FormatTextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& FormatTextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& FormatTextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.FormatTextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void FormatTextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.FormatTextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* FormatTextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* FormatTextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.FormatTextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* FormatTextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* FormatTextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.FormatTextCommandArchive.undo_transaction)
  return _msg;
}
inline void FormatTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.FormatTextCommandArchive.undo_transaction)
}

// optional uint32 selection_range_location = 8;
inline bool FormatTextCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FormatTextCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void FormatTextCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t FormatTextCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t FormatTextCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.FormatTextCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void FormatTextCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_range_location_ = value;
}
inline void FormatTextCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.FormatTextCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 9;
inline bool FormatTextCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FormatTextCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void FormatTextCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t FormatTextCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t FormatTextCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.FormatTextCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void FormatTextCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_length_ = value;
}
inline void FormatTextCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.FormatTextCommandArchive.selection_range_length)
}

// optional uint32 text_command_flags = 11;
inline bool FormatTextCommandArchive::_internal_has_text_command_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FormatTextCommandArchive::has_text_command_flags() const {
  return _internal_has_text_command_flags();
}
inline void FormatTextCommandArchive::clear_text_command_flags() {
  _impl_.text_command_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t FormatTextCommandArchive::_internal_text_command_flags() const {
  return _impl_.text_command_flags_;
}
inline uint32_t FormatTextCommandArchive::text_command_flags() const {
  // @@protoc_insertion_point(field_get:TSWP.FormatTextCommandArchive.text_command_flags)
  return _internal_text_command_flags();
}
inline void FormatTextCommandArchive::_internal_set_text_command_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.text_command_flags_ = value;
}
inline void FormatTextCommandArchive::set_text_command_flags(uint32_t value) {
  _internal_set_text_command_flags(value);
  // @@protoc_insertion_point(field_set:TSWP.FormatTextCommandArchive.text_command_flags)
}

// -------------------------------------------------------------------

// SetColumnStyleCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool SetColumnStyleCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool SetColumnStyleCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& SetColumnStyleCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& SetColumnStyleCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.SetColumnStyleCommandArchive.super)
  return _internal_super();
}
inline void SetColumnStyleCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.SetColumnStyleCommandArchive.super)
}
inline ::TSK::CommandArchive* SetColumnStyleCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* SetColumnStyleCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.SetColumnStyleCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* SetColumnStyleCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* SetColumnStyleCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.SetColumnStyleCommandArchive.super)
  return _msg;
}
inline void SetColumnStyleCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.SetColumnStyleCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool SetColumnStyleCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool SetColumnStyleCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& SetColumnStyleCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& SetColumnStyleCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.SetColumnStyleCommandArchive.storage)
  return _internal_storage();
}
inline void SetColumnStyleCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.SetColumnStyleCommandArchive.storage)
}
inline ::TSP::Reference* SetColumnStyleCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* SetColumnStyleCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.SetColumnStyleCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* SetColumnStyleCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* SetColumnStyleCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.SetColumnStyleCommandArchive.storage)
  return _msg;
}
inline void SetColumnStyleCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.SetColumnStyleCommandArchive.storage)
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool SetColumnStyleCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool SetColumnStyleCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& SetColumnStyleCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& SetColumnStyleCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.SetColumnStyleCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void SetColumnStyleCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.SetColumnStyleCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* SetColumnStyleCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* SetColumnStyleCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.SetColumnStyleCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* SetColumnStyleCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* SetColumnStyleCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.SetColumnStyleCommandArchive.undo_transaction)
  return _msg;
}
inline void SetColumnStyleCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.SetColumnStyleCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// ReplaceAllUsesOfStyleCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ReplaceAllUsesOfStyleCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ReplaceAllUsesOfStyleCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ReplaceAllUsesOfStyleCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ReplaceAllUsesOfStyleCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ReplaceAllUsesOfStyleCommandArchive.super)
  return _internal_super();
}
inline void ReplaceAllUsesOfStyleCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ReplaceAllUsesOfStyleCommandArchive.super)
}
inline ::TSK::CommandArchive* ReplaceAllUsesOfStyleCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAllUsesOfStyleCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ReplaceAllUsesOfStyleCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAllUsesOfStyleCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ReplaceAllUsesOfStyleCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ReplaceAllUsesOfStyleCommandArchive.super)
  return _msg;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ReplaceAllUsesOfStyleCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool ReplaceAllUsesOfStyleCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool ReplaceAllUsesOfStyleCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& ReplaceAllUsesOfStyleCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ReplaceAllUsesOfStyleCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.ReplaceAllUsesOfStyleCommandArchive.storage)
  return _internal_storage();
}
inline void ReplaceAllUsesOfStyleCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ReplaceAllUsesOfStyleCommandArchive.storage)
}
inline ::TSP::Reference* ReplaceAllUsesOfStyleCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ReplaceAllUsesOfStyleCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.ReplaceAllUsesOfStyleCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ReplaceAllUsesOfStyleCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* ReplaceAllUsesOfStyleCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.ReplaceAllUsesOfStyleCommandArchive.storage)
  return _msg;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ReplaceAllUsesOfStyleCommandArchive.storage)
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool ReplaceAllUsesOfStyleCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ReplaceAllUsesOfStyleCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ReplaceAllUsesOfStyleCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ReplaceAllUsesOfStyleCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.ReplaceAllUsesOfStyleCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ReplaceAllUsesOfStyleCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ReplaceAllUsesOfStyleCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ReplaceAllUsesOfStyleCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ReplaceAllUsesOfStyleCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.ReplaceAllUsesOfStyleCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ReplaceAllUsesOfStyleCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ReplaceAllUsesOfStyleCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.ReplaceAllUsesOfStyleCommandArchive.undo_transaction)
  return _msg;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ReplaceAllUsesOfStyleCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// InsertAttachmentCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool InsertAttachmentCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool InsertAttachmentCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& InsertAttachmentCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& InsertAttachmentCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.super)
  return _internal_super();
}
inline void InsertAttachmentCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertAttachmentCommandArchive.super)
}
inline ::TSK::CommandArchive* InsertAttachmentCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* InsertAttachmentCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.InsertAttachmentCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* InsertAttachmentCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* InsertAttachmentCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertAttachmentCommandArchive.super)
  return _msg;
}
inline void InsertAttachmentCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertAttachmentCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool InsertAttachmentCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool InsertAttachmentCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& InsertAttachmentCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& InsertAttachmentCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.storage)
  return _internal_storage();
}
inline void InsertAttachmentCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertAttachmentCommandArchive.storage)
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.InsertAttachmentCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertAttachmentCommandArchive.storage)
  return _msg;
}
inline void InsertAttachmentCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertAttachmentCommandArchive.storage)
}

// optional uint32 selection_range_location = 3;
inline bool InsertAttachmentCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InsertAttachmentCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void InsertAttachmentCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t InsertAttachmentCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t InsertAttachmentCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void InsertAttachmentCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_location_ = value;
}
inline void InsertAttachmentCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertAttachmentCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 4;
inline bool InsertAttachmentCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InsertAttachmentCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void InsertAttachmentCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t InsertAttachmentCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t InsertAttachmentCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void InsertAttachmentCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.selection_range_length_ = value;
}
inline void InsertAttachmentCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertAttachmentCommandArchive.selection_range_length)
}

// optional .TSP.Reference attachment = 5;
inline bool InsertAttachmentCommandArchive::_internal_has_attachment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attachment_ != nullptr);
  return value;
}
inline bool InsertAttachmentCommandArchive::has_attachment() const {
  return _internal_has_attachment();
}
inline const ::TSP::Reference& InsertAttachmentCommandArchive::_internal_attachment() const {
  const ::TSP::Reference* p = _impl_.attachment_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& InsertAttachmentCommandArchive::attachment() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.attachment)
  return _internal_attachment();
}
inline void InsertAttachmentCommandArchive::unsafe_arena_set_allocated_attachment(
    ::TSP::Reference* attachment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  _impl_.attachment_ = attachment;
  if (attachment) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertAttachmentCommandArchive.attachment)
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::release_attachment() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::unsafe_arena_release_attachment() {
  // @@protoc_insertion_point(field_release:TSWP.InsertAttachmentCommandArchive.attachment)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
  return temp;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::_internal_mutable_attachment() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.attachment_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.attachment_ = p;
  }
  return _impl_.attachment_;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::mutable_attachment() {
  ::TSP::Reference* _msg = _internal_mutable_attachment();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertAttachmentCommandArchive.attachment)
  return _msg;
}
inline void InsertAttachmentCommandArchive::set_allocated_attachment(::TSP::Reference* attachment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  if (attachment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attachment));
    if (message_arena != submessage_arena) {
      attachment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attachment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attachment_ = attachment;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertAttachmentCommandArchive.attachment)
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool InsertAttachmentCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool InsertAttachmentCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& InsertAttachmentCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& InsertAttachmentCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void InsertAttachmentCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertAttachmentCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* InsertAttachmentCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* InsertAttachmentCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.InsertAttachmentCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* InsertAttachmentCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertAttachmentCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertAttachmentCommandArchive.undo_transaction)
  return _msg;
}
inline void InsertAttachmentCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertAttachmentCommandArchive.undo_transaction)
}

// optional uint32 text_command_flags = 7;
inline bool InsertAttachmentCommandArchive::_internal_has_text_command_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InsertAttachmentCommandArchive::has_text_command_flags() const {
  return _internal_has_text_command_flags();
}
inline void InsertAttachmentCommandArchive::clear_text_command_flags() {
  _impl_.text_command_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t InsertAttachmentCommandArchive::_internal_text_command_flags() const {
  return _impl_.text_command_flags_;
}
inline uint32_t InsertAttachmentCommandArchive::text_command_flags() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.text_command_flags)
  return _internal_text_command_flags();
}
inline void InsertAttachmentCommandArchive::_internal_set_text_command_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.text_command_flags_ = value;
}
inline void InsertAttachmentCommandArchive::set_text_command_flags(uint32_t value) {
  _internal_set_text_command_flags(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertAttachmentCommandArchive.text_command_flags)
}

// optional uint32 redo_restore_range_location = 8;
inline bool InsertAttachmentCommandArchive::_internal_has_redo_restore_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InsertAttachmentCommandArchive::has_redo_restore_range_location() const {
  return _internal_has_redo_restore_range_location();
}
inline void InsertAttachmentCommandArchive::clear_redo_restore_range_location() {
  _impl_.redo_restore_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t InsertAttachmentCommandArchive::_internal_redo_restore_range_location() const {
  return _impl_.redo_restore_range_location_;
}
inline uint32_t InsertAttachmentCommandArchive::redo_restore_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.redo_restore_range_location)
  return _internal_redo_restore_range_location();
}
inline void InsertAttachmentCommandArchive::_internal_set_redo_restore_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.redo_restore_range_location_ = value;
}
inline void InsertAttachmentCommandArchive::set_redo_restore_range_location(uint32_t value) {
  _internal_set_redo_restore_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertAttachmentCommandArchive.redo_restore_range_location)
}

// optional uint32 redo_restore_range_length = 9;
inline bool InsertAttachmentCommandArchive::_internal_has_redo_restore_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InsertAttachmentCommandArchive::has_redo_restore_range_length() const {
  return _internal_has_redo_restore_range_length();
}
inline void InsertAttachmentCommandArchive::clear_redo_restore_range_length() {
  _impl_.redo_restore_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t InsertAttachmentCommandArchive::_internal_redo_restore_range_length() const {
  return _impl_.redo_restore_range_length_;
}
inline uint32_t InsertAttachmentCommandArchive::redo_restore_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertAttachmentCommandArchive.redo_restore_range_length)
  return _internal_redo_restore_range_length();
}
inline void InsertAttachmentCommandArchive::_internal_set_redo_restore_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.redo_restore_range_length_ = value;
}
inline void InsertAttachmentCommandArchive::set_redo_restore_range_length(uint32_t value) {
  _internal_set_redo_restore_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertAttachmentCommandArchive.redo_restore_range_length)
}

// -------------------------------------------------------------------

// InsertColumnsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool InsertColumnsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool InsertColumnsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& InsertColumnsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& InsertColumnsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertColumnsCommandArchive.super)
  return _internal_super();
}
inline void InsertColumnsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertColumnsCommandArchive.super)
}
inline ::TSK::CommandArchive* InsertColumnsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* InsertColumnsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.InsertColumnsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* InsertColumnsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* InsertColumnsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertColumnsCommandArchive.super)
  return _msg;
}
inline void InsertColumnsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertColumnsCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool InsertColumnsCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool InsertColumnsCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& InsertColumnsCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& InsertColumnsCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertColumnsCommandArchive.storage)
  return _internal_storage();
}
inline void InsertColumnsCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertColumnsCommandArchive.storage)
}
inline ::TSP::Reference* InsertColumnsCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* InsertColumnsCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.InsertColumnsCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* InsertColumnsCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* InsertColumnsCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertColumnsCommandArchive.storage)
  return _msg;
}
inline void InsertColumnsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertColumnsCommandArchive.storage)
}

// optional uint32 column_index = 3;
inline bool InsertColumnsCommandArchive::_internal_has_column_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InsertColumnsCommandArchive::has_column_index() const {
  return _internal_has_column_index();
}
inline void InsertColumnsCommandArchive::clear_column_index() {
  _impl_.column_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t InsertColumnsCommandArchive::_internal_column_index() const {
  return _impl_.column_index_;
}
inline uint32_t InsertColumnsCommandArchive::column_index() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertColumnsCommandArchive.column_index)
  return _internal_column_index();
}
inline void InsertColumnsCommandArchive::_internal_set_column_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.column_index_ = value;
}
inline void InsertColumnsCommandArchive::set_column_index(uint32_t value) {
  _internal_set_column_index(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertColumnsCommandArchive.column_index)
}

// optional uint32 column_count = 4;
inline bool InsertColumnsCommandArchive::_internal_has_column_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InsertColumnsCommandArchive::has_column_count() const {
  return _internal_has_column_count();
}
inline void InsertColumnsCommandArchive::clear_column_count() {
  _impl_.column_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t InsertColumnsCommandArchive::_internal_column_count() const {
  return _impl_.column_count_;
}
inline uint32_t InsertColumnsCommandArchive::column_count() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertColumnsCommandArchive.column_count)
  return _internal_column_count();
}
inline void InsertColumnsCommandArchive::_internal_set_column_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.column_count_ = value;
}
inline void InsertColumnsCommandArchive::set_column_count(uint32_t value) {
  _internal_set_column_count(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertColumnsCommandArchive.column_count)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool InsertColumnsCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool InsertColumnsCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& InsertColumnsCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& InsertColumnsCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertColumnsCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void InsertColumnsCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertColumnsCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* InsertColumnsCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* InsertColumnsCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.InsertColumnsCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* InsertColumnsCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertColumnsCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertColumnsCommandArchive.undo_transaction)
  return _msg;
}
inline void InsertColumnsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertColumnsCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// InsertRowsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool InsertRowsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool InsertRowsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& InsertRowsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& InsertRowsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertRowsCommandArchive.super)
  return _internal_super();
}
inline void InsertRowsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertRowsCommandArchive.super)
}
inline ::TSK::CommandArchive* InsertRowsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* InsertRowsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.InsertRowsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* InsertRowsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* InsertRowsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertRowsCommandArchive.super)
  return _msg;
}
inline void InsertRowsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertRowsCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool InsertRowsCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool InsertRowsCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& InsertRowsCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& InsertRowsCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertRowsCommandArchive.storage)
  return _internal_storage();
}
inline void InsertRowsCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertRowsCommandArchive.storage)
}
inline ::TSP::Reference* InsertRowsCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* InsertRowsCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.InsertRowsCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* InsertRowsCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* InsertRowsCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertRowsCommandArchive.storage)
  return _msg;
}
inline void InsertRowsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertRowsCommandArchive.storage)
}

// optional uint32 row_index = 3;
inline bool InsertRowsCommandArchive::_internal_has_row_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InsertRowsCommandArchive::has_row_index() const {
  return _internal_has_row_index();
}
inline void InsertRowsCommandArchive::clear_row_index() {
  _impl_.row_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t InsertRowsCommandArchive::_internal_row_index() const {
  return _impl_.row_index_;
}
inline uint32_t InsertRowsCommandArchive::row_index() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertRowsCommandArchive.row_index)
  return _internal_row_index();
}
inline void InsertRowsCommandArchive::_internal_set_row_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.row_index_ = value;
}
inline void InsertRowsCommandArchive::set_row_index(uint32_t value) {
  _internal_set_row_index(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertRowsCommandArchive.row_index)
}

// optional uint32 row_count = 4;
inline bool InsertRowsCommandArchive::_internal_has_row_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InsertRowsCommandArchive::has_row_count() const {
  return _internal_has_row_count();
}
inline void InsertRowsCommandArchive::clear_row_count() {
  _impl_.row_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t InsertRowsCommandArchive::_internal_row_count() const {
  return _impl_.row_count_;
}
inline uint32_t InsertRowsCommandArchive::row_count() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertRowsCommandArchive.row_count)
  return _internal_row_count();
}
inline void InsertRowsCommandArchive::_internal_set_row_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.row_count_ = value;
}
inline void InsertRowsCommandArchive::set_row_count(uint32_t value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:TSWP.InsertRowsCommandArchive.row_count)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool InsertRowsCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool InsertRowsCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& InsertRowsCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& InsertRowsCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.InsertRowsCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void InsertRowsCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.InsertRowsCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* InsertRowsCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* InsertRowsCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.InsertRowsCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* InsertRowsCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertRowsCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.InsertRowsCommandArchive.undo_transaction)
  return _msg;
}
inline void InsertRowsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.InsertRowsCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// RemoveColumnsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveColumnsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool RemoveColumnsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& RemoveColumnsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& RemoveColumnsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveColumnsCommandArchive.super)
  return _internal_super();
}
inline void RemoveColumnsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveColumnsCommandArchive.super)
}
inline ::TSK::CommandArchive* RemoveColumnsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* RemoveColumnsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveColumnsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* RemoveColumnsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* RemoveColumnsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveColumnsCommandArchive.super)
  return _msg;
}
inline void RemoveColumnsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveColumnsCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool RemoveColumnsCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool RemoveColumnsCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& RemoveColumnsCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveColumnsCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveColumnsCommandArchive.storage)
  return _internal_storage();
}
inline void RemoveColumnsCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveColumnsCommandArchive.storage)
}
inline ::TSP::Reference* RemoveColumnsCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveColumnsCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveColumnsCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveColumnsCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* RemoveColumnsCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveColumnsCommandArchive.storage)
  return _msg;
}
inline void RemoveColumnsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveColumnsCommandArchive.storage)
}

// optional uint32 column_index = 3;
inline bool RemoveColumnsCommandArchive::_internal_has_column_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoveColumnsCommandArchive::has_column_index() const {
  return _internal_has_column_index();
}
inline void RemoveColumnsCommandArchive::clear_column_index() {
  _impl_.column_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RemoveColumnsCommandArchive::_internal_column_index() const {
  return _impl_.column_index_;
}
inline uint32_t RemoveColumnsCommandArchive::column_index() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveColumnsCommandArchive.column_index)
  return _internal_column_index();
}
inline void RemoveColumnsCommandArchive::_internal_set_column_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.column_index_ = value;
}
inline void RemoveColumnsCommandArchive::set_column_index(uint32_t value) {
  _internal_set_column_index(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveColumnsCommandArchive.column_index)
}

// optional uint32 column_count = 4;
inline bool RemoveColumnsCommandArchive::_internal_has_column_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RemoveColumnsCommandArchive::has_column_count() const {
  return _internal_has_column_count();
}
inline void RemoveColumnsCommandArchive::clear_column_count() {
  _impl_.column_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t RemoveColumnsCommandArchive::_internal_column_count() const {
  return _impl_.column_count_;
}
inline uint32_t RemoveColumnsCommandArchive::column_count() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveColumnsCommandArchive.column_count)
  return _internal_column_count();
}
inline void RemoveColumnsCommandArchive::_internal_set_column_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.column_count_ = value;
}
inline void RemoveColumnsCommandArchive::set_column_count(uint32_t value) {
  _internal_set_column_count(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveColumnsCommandArchive.column_count)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveColumnsCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool RemoveColumnsCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveColumnsCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& RemoveColumnsCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveColumnsCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void RemoveColumnsCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveColumnsCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* RemoveColumnsCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveColumnsCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveColumnsCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveColumnsCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveColumnsCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveColumnsCommandArchive.undo_transaction)
  return _msg;
}
inline void RemoveColumnsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveColumnsCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// RemoveRowsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveRowsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool RemoveRowsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& RemoveRowsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& RemoveRowsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRowsCommandArchive.super)
  return _internal_super();
}
inline void RemoveRowsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveRowsCommandArchive.super)
}
inline ::TSK::CommandArchive* RemoveRowsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* RemoveRowsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveRowsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* RemoveRowsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* RemoveRowsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveRowsCommandArchive.super)
  return _msg;
}
inline void RemoveRowsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveRowsCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool RemoveRowsCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool RemoveRowsCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& RemoveRowsCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveRowsCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRowsCommandArchive.storage)
  return _internal_storage();
}
inline void RemoveRowsCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveRowsCommandArchive.storage)
}
inline ::TSP::Reference* RemoveRowsCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveRowsCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveRowsCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveRowsCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* RemoveRowsCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveRowsCommandArchive.storage)
  return _msg;
}
inline void RemoveRowsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveRowsCommandArchive.storage)
}

// optional uint32 row_index = 3;
inline bool RemoveRowsCommandArchive::_internal_has_row_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoveRowsCommandArchive::has_row_index() const {
  return _internal_has_row_index();
}
inline void RemoveRowsCommandArchive::clear_row_index() {
  _impl_.row_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RemoveRowsCommandArchive::_internal_row_index() const {
  return _impl_.row_index_;
}
inline uint32_t RemoveRowsCommandArchive::row_index() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRowsCommandArchive.row_index)
  return _internal_row_index();
}
inline void RemoveRowsCommandArchive::_internal_set_row_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.row_index_ = value;
}
inline void RemoveRowsCommandArchive::set_row_index(uint32_t value) {
  _internal_set_row_index(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveRowsCommandArchive.row_index)
}

// optional uint32 row_count = 4;
inline bool RemoveRowsCommandArchive::_internal_has_row_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RemoveRowsCommandArchive::has_row_count() const {
  return _internal_has_row_count();
}
inline void RemoveRowsCommandArchive::clear_row_count() {
  _impl_.row_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t RemoveRowsCommandArchive::_internal_row_count() const {
  return _impl_.row_count_;
}
inline uint32_t RemoveRowsCommandArchive::row_count() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRowsCommandArchive.row_count)
  return _internal_row_count();
}
inline void RemoveRowsCommandArchive::_internal_set_row_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.row_count_ = value;
}
inline void RemoveRowsCommandArchive::set_row_count(uint32_t value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveRowsCommandArchive.row_count)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveRowsCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool RemoveRowsCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveRowsCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& RemoveRowsCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRowsCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void RemoveRowsCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveRowsCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* RemoveRowsCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveRowsCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveRowsCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveRowsCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveRowsCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveRowsCommandArchive.undo_transaction)
  return _msg;
}
inline void RemoveRowsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveRowsCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// MergeCellsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool MergeCellsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MergeCellsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MergeCellsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MergeCellsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.MergeCellsCommandArchive.super)
  return _internal_super();
}
inline void MergeCellsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MergeCellsCommandArchive.super)
}
inline ::TSK::CommandArchive* MergeCellsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MergeCellsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.MergeCellsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MergeCellsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MergeCellsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.MergeCellsCommandArchive.super)
  return _msg;
}
inline void MergeCellsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MergeCellsCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool MergeCellsCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool MergeCellsCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& MergeCellsCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MergeCellsCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.MergeCellsCommandArchive.storage)
  return _internal_storage();
}
inline void MergeCellsCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MergeCellsCommandArchive.storage)
}
inline ::TSP::Reference* MergeCellsCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MergeCellsCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.MergeCellsCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MergeCellsCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* MergeCellsCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.MergeCellsCommandArchive.storage)
  return _msg;
}
inline void MergeCellsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MergeCellsCommandArchive.storage)
}

// optional uint32 row = 3;
inline bool MergeCellsCommandArchive::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MergeCellsCommandArchive::has_row() const {
  return _internal_has_row();
}
inline void MergeCellsCommandArchive::clear_row() {
  _impl_.row_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MergeCellsCommandArchive::_internal_row() const {
  return _impl_.row_;
}
inline uint32_t MergeCellsCommandArchive::row() const {
  // @@protoc_insertion_point(field_get:TSWP.MergeCellsCommandArchive.row)
  return _internal_row();
}
inline void MergeCellsCommandArchive::_internal_set_row(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.row_ = value;
}
inline void MergeCellsCommandArchive::set_row(uint32_t value) {
  _internal_set_row(value);
  // @@protoc_insertion_point(field_set:TSWP.MergeCellsCommandArchive.row)
}

// optional uint32 column = 4;
inline bool MergeCellsCommandArchive::_internal_has_column() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MergeCellsCommandArchive::has_column() const {
  return _internal_has_column();
}
inline void MergeCellsCommandArchive::clear_column() {
  _impl_.column_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MergeCellsCommandArchive::_internal_column() const {
  return _impl_.column_;
}
inline uint32_t MergeCellsCommandArchive::column() const {
  // @@protoc_insertion_point(field_get:TSWP.MergeCellsCommandArchive.column)
  return _internal_column();
}
inline void MergeCellsCommandArchive::_internal_set_column(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.column_ = value;
}
inline void MergeCellsCommandArchive::set_column(uint32_t value) {
  _internal_set_column(value);
  // @@protoc_insertion_point(field_set:TSWP.MergeCellsCommandArchive.column)
}

// optional uint32 row_count = 5;
inline bool MergeCellsCommandArchive::_internal_has_row_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MergeCellsCommandArchive::has_row_count() const {
  return _internal_has_row_count();
}
inline void MergeCellsCommandArchive::clear_row_count() {
  _impl_.row_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MergeCellsCommandArchive::_internal_row_count() const {
  return _impl_.row_count_;
}
inline uint32_t MergeCellsCommandArchive::row_count() const {
  // @@protoc_insertion_point(field_get:TSWP.MergeCellsCommandArchive.row_count)
  return _internal_row_count();
}
inline void MergeCellsCommandArchive::_internal_set_row_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.row_count_ = value;
}
inline void MergeCellsCommandArchive::set_row_count(uint32_t value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:TSWP.MergeCellsCommandArchive.row_count)
}

// optional uint32 column_count = 6;
inline bool MergeCellsCommandArchive::_internal_has_column_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MergeCellsCommandArchive::has_column_count() const {
  return _internal_has_column_count();
}
inline void MergeCellsCommandArchive::clear_column_count() {
  _impl_.column_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t MergeCellsCommandArchive::_internal_column_count() const {
  return _impl_.column_count_;
}
inline uint32_t MergeCellsCommandArchive::column_count() const {
  // @@protoc_insertion_point(field_get:TSWP.MergeCellsCommandArchive.column_count)
  return _internal_column_count();
}
inline void MergeCellsCommandArchive::_internal_set_column_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.column_count_ = value;
}
inline void MergeCellsCommandArchive::set_column_count(uint32_t value) {
  _internal_set_column_count(value);
  // @@protoc_insertion_point(field_set:TSWP.MergeCellsCommandArchive.column_count)
}

// optional .TSWP.UndoTransaction undo_transaction = 7;
inline bool MergeCellsCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool MergeCellsCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MergeCellsCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& MergeCellsCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.MergeCellsCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void MergeCellsCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MergeCellsCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* MergeCellsCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* MergeCellsCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.MergeCellsCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* MergeCellsCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* MergeCellsCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.MergeCellsCommandArchive.undo_transaction)
  return _msg;
}
inline void MergeCellsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MergeCellsCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// ApplyPlaceholderTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ApplyPlaceholderTextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ApplyPlaceholderTextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ApplyPlaceholderTextCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ApplyPlaceholderTextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyPlaceholderTextCommandArchive.super)
  return _internal_super();
}
inline void ApplyPlaceholderTextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyPlaceholderTextCommandArchive.super)
}
inline ::TSK::CommandArchive* ApplyPlaceholderTextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ApplyPlaceholderTextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyPlaceholderTextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ApplyPlaceholderTextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ApplyPlaceholderTextCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyPlaceholderTextCommandArchive.super)
  return _msg;
}
inline void ApplyPlaceholderTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyPlaceholderTextCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool ApplyPlaceholderTextCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool ApplyPlaceholderTextCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& ApplyPlaceholderTextCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ApplyPlaceholderTextCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyPlaceholderTextCommandArchive.storage)
  return _internal_storage();
}
inline void ApplyPlaceholderTextCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyPlaceholderTextCommandArchive.storage)
}
inline ::TSP::Reference* ApplyPlaceholderTextCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ApplyPlaceholderTextCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyPlaceholderTextCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ApplyPlaceholderTextCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* ApplyPlaceholderTextCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyPlaceholderTextCommandArchive.storage)
  return _msg;
}
inline void ApplyPlaceholderTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyPlaceholderTextCommandArchive.storage)
}

// optional uint32 selection_range_location = 3;
inline bool ApplyPlaceholderTextCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApplyPlaceholderTextCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void ApplyPlaceholderTextCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ApplyPlaceholderTextCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t ApplyPlaceholderTextCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyPlaceholderTextCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void ApplyPlaceholderTextCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_range_location_ = value;
}
inline void ApplyPlaceholderTextCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.ApplyPlaceholderTextCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 4;
inline bool ApplyPlaceholderTextCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApplyPlaceholderTextCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void ApplyPlaceholderTextCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ApplyPlaceholderTextCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t ApplyPlaceholderTextCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyPlaceholderTextCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void ApplyPlaceholderTextCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_length_ = value;
}
inline void ApplyPlaceholderTextCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.ApplyPlaceholderTextCommandArchive.selection_range_length)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ApplyPlaceholderTextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ApplyPlaceholderTextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ApplyPlaceholderTextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ApplyPlaceholderTextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyPlaceholderTextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ApplyPlaceholderTextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyPlaceholderTextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ApplyPlaceholderTextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ApplyPlaceholderTextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyPlaceholderTextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ApplyPlaceholderTextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyPlaceholderTextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyPlaceholderTextCommandArchive.undo_transaction)
  return _msg;
}
inline void ApplyPlaceholderTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyPlaceholderTextCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// ApplyHighlightTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ApplyHighlightTextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ApplyHighlightTextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ApplyHighlightTextCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ApplyHighlightTextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyHighlightTextCommandArchive.super)
  return _internal_super();
}
inline void ApplyHighlightTextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyHighlightTextCommandArchive.super)
}
inline ::TSK::CommandArchive* ApplyHighlightTextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ApplyHighlightTextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyHighlightTextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ApplyHighlightTextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ApplyHighlightTextCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyHighlightTextCommandArchive.super)
  return _msg;
}
inline void ApplyHighlightTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyHighlightTextCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool ApplyHighlightTextCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool ApplyHighlightTextCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& ApplyHighlightTextCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ApplyHighlightTextCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyHighlightTextCommandArchive.storage)
  return _internal_storage();
}
inline void ApplyHighlightTextCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyHighlightTextCommandArchive.storage)
}
inline ::TSP::Reference* ApplyHighlightTextCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ApplyHighlightTextCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyHighlightTextCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ApplyHighlightTextCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* ApplyHighlightTextCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyHighlightTextCommandArchive.storage)
  return _msg;
}
inline void ApplyHighlightTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyHighlightTextCommandArchive.storage)
}

// optional uint32 selection_range_location = 3;
inline bool ApplyHighlightTextCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApplyHighlightTextCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void ApplyHighlightTextCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ApplyHighlightTextCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t ApplyHighlightTextCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyHighlightTextCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void ApplyHighlightTextCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_range_location_ = value;
}
inline void ApplyHighlightTextCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.ApplyHighlightTextCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 4;
inline bool ApplyHighlightTextCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApplyHighlightTextCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void ApplyHighlightTextCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ApplyHighlightTextCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t ApplyHighlightTextCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyHighlightTextCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void ApplyHighlightTextCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_length_ = value;
}
inline void ApplyHighlightTextCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.ApplyHighlightTextCommandArchive.selection_range_length)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ApplyHighlightTextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ApplyHighlightTextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ApplyHighlightTextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ApplyHighlightTextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyHighlightTextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ApplyHighlightTextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyHighlightTextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ApplyHighlightTextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ApplyHighlightTextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyHighlightTextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ApplyHighlightTextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyHighlightTextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyHighlightTextCommandArchive.undo_transaction)
  return _msg;
}
inline void ApplyHighlightTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyHighlightTextCommandArchive.undo_transaction)
}

// optional bool remove = 6;
inline bool ApplyHighlightTextCommandArchive::_internal_has_remove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ApplyHighlightTextCommandArchive::has_remove() const {
  return _internal_has_remove();
}
inline void ApplyHighlightTextCommandArchive::clear_remove() {
  _impl_.remove_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ApplyHighlightTextCommandArchive::_internal_remove() const {
  return _impl_.remove_;
}
inline bool ApplyHighlightTextCommandArchive::remove() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyHighlightTextCommandArchive.remove)
  return _internal_remove();
}
inline void ApplyHighlightTextCommandArchive::_internal_set_remove(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.remove_ = value;
}
inline void ApplyHighlightTextCommandArchive::set_remove(bool value) {
  _internal_set_remove(value);
  // @@protoc_insertion_point(field_set:TSWP.ApplyHighlightTextCommandArchive.remove)
}

// -------------------------------------------------------------------

// CreateHyperlinkCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool CreateHyperlinkCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool CreateHyperlinkCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& CreateHyperlinkCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& CreateHyperlinkCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.CreateHyperlinkCommandArchive.super)
  return _internal_super();
}
inline void CreateHyperlinkCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.CreateHyperlinkCommandArchive.super)
}
inline ::TSK::CommandArchive* CreateHyperlinkCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* CreateHyperlinkCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.CreateHyperlinkCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* CreateHyperlinkCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* CreateHyperlinkCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.CreateHyperlinkCommandArchive.super)
  return _msg;
}
inline void CreateHyperlinkCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.CreateHyperlinkCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool CreateHyperlinkCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool CreateHyperlinkCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& CreateHyperlinkCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CreateHyperlinkCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.CreateHyperlinkCommandArchive.storage)
  return _internal_storage();
}
inline void CreateHyperlinkCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.CreateHyperlinkCommandArchive.storage)
}
inline ::TSP::Reference* CreateHyperlinkCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CreateHyperlinkCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.CreateHyperlinkCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CreateHyperlinkCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* CreateHyperlinkCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.CreateHyperlinkCommandArchive.storage)
  return _msg;
}
inline void CreateHyperlinkCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.CreateHyperlinkCommandArchive.storage)
}

// optional uint32 selection_range_location = 3;
inline bool CreateHyperlinkCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CreateHyperlinkCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void CreateHyperlinkCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CreateHyperlinkCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t CreateHyperlinkCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.CreateHyperlinkCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void CreateHyperlinkCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_location_ = value;
}
inline void CreateHyperlinkCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.CreateHyperlinkCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 4;
inline bool CreateHyperlinkCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CreateHyperlinkCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void CreateHyperlinkCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CreateHyperlinkCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t CreateHyperlinkCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.CreateHyperlinkCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void CreateHyperlinkCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.selection_range_length_ = value;
}
inline void CreateHyperlinkCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.CreateHyperlinkCommandArchive.selection_range_length)
}

// optional string url_ref = 5;
inline bool CreateHyperlinkCommandArchive::_internal_has_url_ref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateHyperlinkCommandArchive::has_url_ref() const {
  return _internal_has_url_ref();
}
inline void CreateHyperlinkCommandArchive::clear_url_ref() {
  _impl_.url_ref_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateHyperlinkCommandArchive::url_ref() const {
  // @@protoc_insertion_point(field_get:TSWP.CreateHyperlinkCommandArchive.url_ref)
  return _internal_url_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateHyperlinkCommandArchive::set_url_ref(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.CreateHyperlinkCommandArchive.url_ref)
}
inline std::string* CreateHyperlinkCommandArchive::mutable_url_ref() {
  std::string* _s = _internal_mutable_url_ref();
  // @@protoc_insertion_point(field_mutable:TSWP.CreateHyperlinkCommandArchive.url_ref)
  return _s;
}
inline const std::string& CreateHyperlinkCommandArchive::_internal_url_ref() const {
  return _impl_.url_ref_.Get();
}
inline void CreateHyperlinkCommandArchive::_internal_set_url_ref(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateHyperlinkCommandArchive::_internal_mutable_url_ref() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateHyperlinkCommandArchive::release_url_ref() {
  // @@protoc_insertion_point(field_release:TSWP.CreateHyperlinkCommandArchive.url_ref)
  if (!_internal_has_url_ref()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_ref_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_ref_.IsDefault()) {
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateHyperlinkCommandArchive::set_allocated_url_ref(std::string* url_ref) {
  if (url_ref != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_ref_.SetAllocated(url_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_ref_.IsDefault()) {
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.CreateHyperlinkCommandArchive.url_ref)
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool CreateHyperlinkCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool CreateHyperlinkCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& CreateHyperlinkCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& CreateHyperlinkCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.CreateHyperlinkCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void CreateHyperlinkCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.CreateHyperlinkCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* CreateHyperlinkCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* CreateHyperlinkCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.CreateHyperlinkCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* CreateHyperlinkCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* CreateHyperlinkCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.CreateHyperlinkCommandArchive.undo_transaction)
  return _msg;
}
inline void CreateHyperlinkCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.CreateHyperlinkCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// RemoveHyperlinkCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveHyperlinkCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool RemoveHyperlinkCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& RemoveHyperlinkCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& RemoveHyperlinkCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveHyperlinkCommandArchive.super)
  return _internal_super();
}
inline void RemoveHyperlinkCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveHyperlinkCommandArchive.super)
}
inline ::TSK::CommandArchive* RemoveHyperlinkCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* RemoveHyperlinkCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveHyperlinkCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* RemoveHyperlinkCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* RemoveHyperlinkCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveHyperlinkCommandArchive.super)
  return _msg;
}
inline void RemoveHyperlinkCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveHyperlinkCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool RemoveHyperlinkCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool RemoveHyperlinkCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& RemoveHyperlinkCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveHyperlinkCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveHyperlinkCommandArchive.storage)
  return _internal_storage();
}
inline void RemoveHyperlinkCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveHyperlinkCommandArchive.storage)
}
inline ::TSP::Reference* RemoveHyperlinkCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveHyperlinkCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveHyperlinkCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveHyperlinkCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* RemoveHyperlinkCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveHyperlinkCommandArchive.storage)
  return _msg;
}
inline void RemoveHyperlinkCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveHyperlinkCommandArchive.storage)
}

// optional uint32 selection_range_location = 3;
inline bool RemoveHyperlinkCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoveHyperlinkCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void RemoveHyperlinkCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RemoveHyperlinkCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t RemoveHyperlinkCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveHyperlinkCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void RemoveHyperlinkCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_range_location_ = value;
}
inline void RemoveHyperlinkCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveHyperlinkCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 4;
inline bool RemoveHyperlinkCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RemoveHyperlinkCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void RemoveHyperlinkCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t RemoveHyperlinkCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t RemoveHyperlinkCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveHyperlinkCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void RemoveHyperlinkCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_length_ = value;
}
inline void RemoveHyperlinkCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveHyperlinkCommandArchive.selection_range_length)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveHyperlinkCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool RemoveHyperlinkCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveHyperlinkCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& RemoveHyperlinkCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveHyperlinkCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void RemoveHyperlinkCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveHyperlinkCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* RemoveHyperlinkCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveHyperlinkCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveHyperlinkCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveHyperlinkCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveHyperlinkCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveHyperlinkCommandArchive.undo_transaction)
  return _msg;
}
inline void RemoveHyperlinkCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveHyperlinkCommandArchive.undo_transaction)
}

// optional bool is_remove_character_style = 6 [default = true];
inline bool RemoveHyperlinkCommandArchive::_internal_has_is_remove_character_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RemoveHyperlinkCommandArchive::has_is_remove_character_style() const {
  return _internal_has_is_remove_character_style();
}
inline void RemoveHyperlinkCommandArchive::clear_is_remove_character_style() {
  _impl_.is_remove_character_style_ = true;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool RemoveHyperlinkCommandArchive::_internal_is_remove_character_style() const {
  return _impl_.is_remove_character_style_;
}
inline bool RemoveHyperlinkCommandArchive::is_remove_character_style() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveHyperlinkCommandArchive.is_remove_character_style)
  return _internal_is_remove_character_style();
}
inline void RemoveHyperlinkCommandArchive::_internal_set_is_remove_character_style(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_remove_character_style_ = value;
}
inline void RemoveHyperlinkCommandArchive::set_is_remove_character_style(bool value) {
  _internal_set_is_remove_character_style(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveHyperlinkCommandArchive.is_remove_character_style)
}

// -------------------------------------------------------------------

// ModifyHyperlinkCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ModifyHyperlinkCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ModifyHyperlinkCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ModifyHyperlinkCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ModifyHyperlinkCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyHyperlinkCommandArchive.super)
  return _internal_super();
}
inline void ModifyHyperlinkCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyHyperlinkCommandArchive.super)
}
inline ::TSK::CommandArchive* ModifyHyperlinkCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ModifyHyperlinkCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyHyperlinkCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ModifyHyperlinkCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ModifyHyperlinkCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyHyperlinkCommandArchive.super)
  return _msg;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyHyperlinkCommandArchive.super)
}

// optional .TSP.Reference hyperlink = 2;
inline bool ModifyHyperlinkCommandArchive::_internal_has_hyperlink() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hyperlink_ != nullptr);
  return value;
}
inline bool ModifyHyperlinkCommandArchive::has_hyperlink() const {
  return _internal_has_hyperlink();
}
inline const ::TSP::Reference& ModifyHyperlinkCommandArchive::_internal_hyperlink() const {
  const ::TSP::Reference* p = _impl_.hyperlink_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ModifyHyperlinkCommandArchive::hyperlink() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyHyperlinkCommandArchive.hyperlink)
  return _internal_hyperlink();
}
inline void ModifyHyperlinkCommandArchive::unsafe_arena_set_allocated_hyperlink(
    ::TSP::Reference* hyperlink) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hyperlink_);
  }
  _impl_.hyperlink_ = hyperlink;
  if (hyperlink) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyHyperlinkCommandArchive.hyperlink)
}
inline ::TSP::Reference* ModifyHyperlinkCommandArchive::release_hyperlink() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.hyperlink_;
  _impl_.hyperlink_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ModifyHyperlinkCommandArchive::unsafe_arena_release_hyperlink() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyHyperlinkCommandArchive.hyperlink)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.hyperlink_;
  _impl_.hyperlink_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ModifyHyperlinkCommandArchive::_internal_mutable_hyperlink() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.hyperlink_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.hyperlink_ = p;
  }
  return _impl_.hyperlink_;
}
inline ::TSP::Reference* ModifyHyperlinkCommandArchive::mutable_hyperlink() {
  ::TSP::Reference* _msg = _internal_mutable_hyperlink();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyHyperlinkCommandArchive.hyperlink)
  return _msg;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_hyperlink(::TSP::Reference* hyperlink) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hyperlink_);
  }
  if (hyperlink) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hyperlink));
    if (message_arena != submessage_arena) {
      hyperlink = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hyperlink, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.hyperlink_ = hyperlink;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyHyperlinkCommandArchive.hyperlink)
}

// optional string display_text = 3;
inline bool ModifyHyperlinkCommandArchive::_internal_has_display_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModifyHyperlinkCommandArchive::has_display_text() const {
  return _internal_has_display_text();
}
inline void ModifyHyperlinkCommandArchive::clear_display_text() {
  _impl_.display_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModifyHyperlinkCommandArchive::display_text() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyHyperlinkCommandArchive.display_text)
  return _internal_display_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyHyperlinkCommandArchive::set_display_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.display_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.ModifyHyperlinkCommandArchive.display_text)
}
inline std::string* ModifyHyperlinkCommandArchive::mutable_display_text() {
  std::string* _s = _internal_mutable_display_text();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyHyperlinkCommandArchive.display_text)
  return _s;
}
inline const std::string& ModifyHyperlinkCommandArchive::_internal_display_text() const {
  return _impl_.display_text_.Get();
}
inline void ModifyHyperlinkCommandArchive::_internal_set_display_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.display_text_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyHyperlinkCommandArchive::_internal_mutable_display_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.display_text_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyHyperlinkCommandArchive::release_display_text() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyHyperlinkCommandArchive.display_text)
  if (!_internal_has_display_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.display_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_text_.IsDefault()) {
    _impl_.display_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_display_text(std::string* display_text) {
  if (display_text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.display_text_.SetAllocated(display_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_text_.IsDefault()) {
    _impl_.display_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyHyperlinkCommandArchive.display_text)
}

// optional string url_ref = 4;
inline bool ModifyHyperlinkCommandArchive::_internal_has_url_ref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModifyHyperlinkCommandArchive::has_url_ref() const {
  return _internal_has_url_ref();
}
inline void ModifyHyperlinkCommandArchive::clear_url_ref() {
  _impl_.url_ref_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModifyHyperlinkCommandArchive::url_ref() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyHyperlinkCommandArchive.url_ref)
  return _internal_url_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyHyperlinkCommandArchive::set_url_ref(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.url_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.ModifyHyperlinkCommandArchive.url_ref)
}
inline std::string* ModifyHyperlinkCommandArchive::mutable_url_ref() {
  std::string* _s = _internal_mutable_url_ref();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyHyperlinkCommandArchive.url_ref)
  return _s;
}
inline const std::string& ModifyHyperlinkCommandArchive::_internal_url_ref() const {
  return _impl_.url_ref_.Get();
}
inline void ModifyHyperlinkCommandArchive::_internal_set_url_ref(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyHyperlinkCommandArchive::_internal_mutable_url_ref() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyHyperlinkCommandArchive::release_url_ref() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyHyperlinkCommandArchive.url_ref)
  if (!_internal_has_url_ref()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.url_ref_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_ref_.IsDefault()) {
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_url_ref(std::string* url_ref) {
  if (url_ref != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_ref_.SetAllocated(url_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_ref_.IsDefault()) {
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyHyperlinkCommandArchive.url_ref)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ModifyHyperlinkCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ModifyHyperlinkCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ModifyHyperlinkCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ModifyHyperlinkCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyHyperlinkCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ModifyHyperlinkCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyHyperlinkCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ModifyHyperlinkCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ModifyHyperlinkCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyHyperlinkCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ModifyHyperlinkCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ModifyHyperlinkCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyHyperlinkCommandArchive.undo_transaction)
  return _msg;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyHyperlinkCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// UpdateDateTimeFieldCommandArchive

// optional .TSWP.TextCommandArchive super = 1;
inline bool UpdateDateTimeFieldCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool UpdateDateTimeFieldCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void UpdateDateTimeFieldCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSWP::TextCommandArchive& UpdateDateTimeFieldCommandArchive::_internal_super() const {
  const ::TSWP::TextCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::TextCommandArchive&>(
      ::TSWP::_TextCommandArchive_default_instance_);
}
inline const ::TSWP::TextCommandArchive& UpdateDateTimeFieldCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.UpdateDateTimeFieldCommandArchive.super)
  return _internal_super();
}
inline void UpdateDateTimeFieldCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::TextCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.UpdateDateTimeFieldCommandArchive.super)
}
inline ::TSWP::TextCommandArchive* UpdateDateTimeFieldCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::TextCommandArchive* UpdateDateTimeFieldCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.UpdateDateTimeFieldCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::TextCommandArchive* UpdateDateTimeFieldCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::TextCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::TextCommandArchive* UpdateDateTimeFieldCommandArchive::mutable_super() {
  ::TSWP::TextCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.UpdateDateTimeFieldCommandArchive.super)
  return _msg;
}
inline void UpdateDateTimeFieldCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.UpdateDateTimeFieldCommandArchive.super)
}

// optional .TSP.Reference date_time_field = 2;
inline bool UpdateDateTimeFieldCommandArchive::_internal_has_date_time_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.date_time_field_ != nullptr);
  return value;
}
inline bool UpdateDateTimeFieldCommandArchive::has_date_time_field() const {
  return _internal_has_date_time_field();
}
inline const ::TSP::Reference& UpdateDateTimeFieldCommandArchive::_internal_date_time_field() const {
  const ::TSP::Reference* p = _impl_.date_time_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& UpdateDateTimeFieldCommandArchive::date_time_field() const {
  // @@protoc_insertion_point(field_get:TSWP.UpdateDateTimeFieldCommandArchive.date_time_field)
  return _internal_date_time_field();
}
inline void UpdateDateTimeFieldCommandArchive::unsafe_arena_set_allocated_date_time_field(
    ::TSP::Reference* date_time_field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_time_field_);
  }
  _impl_.date_time_field_ = date_time_field;
  if (date_time_field) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.UpdateDateTimeFieldCommandArchive.date_time_field)
}
inline ::TSP::Reference* UpdateDateTimeFieldCommandArchive::release_date_time_field() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.date_time_field_;
  _impl_.date_time_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* UpdateDateTimeFieldCommandArchive::unsafe_arena_release_date_time_field() {
  // @@protoc_insertion_point(field_release:TSWP.UpdateDateTimeFieldCommandArchive.date_time_field)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.date_time_field_;
  _impl_.date_time_field_ = nullptr;
  return temp;
}
inline ::TSP::Reference* UpdateDateTimeFieldCommandArchive::_internal_mutable_date_time_field() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.date_time_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.date_time_field_ = p;
  }
  return _impl_.date_time_field_;
}
inline ::TSP::Reference* UpdateDateTimeFieldCommandArchive::mutable_date_time_field() {
  ::TSP::Reference* _msg = _internal_mutable_date_time_field();
  // @@protoc_insertion_point(field_mutable:TSWP.UpdateDateTimeFieldCommandArchive.date_time_field)
  return _msg;
}
inline void UpdateDateTimeFieldCommandArchive::set_allocated_date_time_field(::TSP::Reference* date_time_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_time_field_);
  }
  if (date_time_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_time_field));
    if (message_arena != submessage_arena) {
      date_time_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_time_field, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.date_time_field_ = date_time_field;
  // @@protoc_insertion_point(field_set_allocated:TSWP.UpdateDateTimeFieldCommandArchive.date_time_field)
}

// optional .TSP.Date date = 3;
inline bool UpdateDateTimeFieldCommandArchive::_internal_has_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.date_ != nullptr);
  return value;
}
inline bool UpdateDateTimeFieldCommandArchive::has_date() const {
  return _internal_has_date();
}
inline const ::TSP::Date& UpdateDateTimeFieldCommandArchive::_internal_date() const {
  const ::TSP::Date* p = _impl_.date_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Date&>(
      ::TSP::_Date_default_instance_);
}
inline const ::TSP::Date& UpdateDateTimeFieldCommandArchive::date() const {
  // @@protoc_insertion_point(field_get:TSWP.UpdateDateTimeFieldCommandArchive.date)
  return _internal_date();
}
inline void UpdateDateTimeFieldCommandArchive::unsafe_arena_set_allocated_date(
    ::TSP::Date* date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_);
  }
  _impl_.date_ = date;
  if (date) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.UpdateDateTimeFieldCommandArchive.date)
}
inline ::TSP::Date* UpdateDateTimeFieldCommandArchive::release_date() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Date* temp = _impl_.date_;
  _impl_.date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Date* UpdateDateTimeFieldCommandArchive::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_release:TSWP.UpdateDateTimeFieldCommandArchive.date)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Date* temp = _impl_.date_;
  _impl_.date_ = nullptr;
  return temp;
}
inline ::TSP::Date* UpdateDateTimeFieldCommandArchive::_internal_mutable_date() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.date_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Date>(GetArenaForAllocation());
    _impl_.date_ = p;
  }
  return _impl_.date_;
}
inline ::TSP::Date* UpdateDateTimeFieldCommandArchive::mutable_date() {
  ::TSP::Date* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:TSWP.UpdateDateTimeFieldCommandArchive.date)
  return _msg;
}
inline void UpdateDateTimeFieldCommandArchive::set_allocated_date(::TSP::Date* date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_);
  }
  if (date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date));
    if (message_arena != submessage_arena) {
      date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.date_ = date;
  // @@protoc_insertion_point(field_set_allocated:TSWP.UpdateDateTimeFieldCommandArchive.date)
}

// optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
inline bool UpdateDateTimeFieldCommandArchive::_internal_has_date_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdateDateTimeFieldCommandArchive::has_date_style() const {
  return _internal_has_date_style();
}
inline void UpdateDateTimeFieldCommandArchive::clear_date_style() {
  _impl_.date_style_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle UpdateDateTimeFieldCommandArchive::_internal_date_style() const {
  return static_cast< ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle >(_impl_.date_style_);
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle UpdateDateTimeFieldCommandArchive::date_style() const {
  // @@protoc_insertion_point(field_get:TSWP.UpdateDateTimeFieldCommandArchive.date_style)
  return _internal_date_style();
}
inline void UpdateDateTimeFieldCommandArchive::_internal_set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  assert(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.date_style_ = value;
}
inline void UpdateDateTimeFieldCommandArchive::set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  _internal_set_date_style(value);
  // @@protoc_insertion_point(field_set:TSWP.UpdateDateTimeFieldCommandArchive.date_style)
}

// optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
inline bool UpdateDateTimeFieldCommandArchive::_internal_has_time_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UpdateDateTimeFieldCommandArchive::has_time_style() const {
  return _internal_has_time_style();
}
inline void UpdateDateTimeFieldCommandArchive::clear_time_style() {
  _impl_.time_style_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle UpdateDateTimeFieldCommandArchive::_internal_time_style() const {
  return static_cast< ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle >(_impl_.time_style_);
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle UpdateDateTimeFieldCommandArchive::time_style() const {
  // @@protoc_insertion_point(field_get:TSWP.UpdateDateTimeFieldCommandArchive.time_style)
  return _internal_time_style();
}
inline void UpdateDateTimeFieldCommandArchive::_internal_set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  assert(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.time_style_ = value;
}
inline void UpdateDateTimeFieldCommandArchive::set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  _internal_set_time_style(value);
  // @@protoc_insertion_point(field_set:TSWP.UpdateDateTimeFieldCommandArchive.time_style)
}

// -------------------------------------------------------------------

// ApplyRubyTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ApplyRubyTextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ApplyRubyTextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ApplyRubyTextCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ApplyRubyTextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyRubyTextCommandArchive.super)
  return _internal_super();
}
inline void ApplyRubyTextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyRubyTextCommandArchive.super)
}
inline ::TSK::CommandArchive* ApplyRubyTextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ApplyRubyTextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyRubyTextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ApplyRubyTextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ApplyRubyTextCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyRubyTextCommandArchive.super)
  return _msg;
}
inline void ApplyRubyTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyRubyTextCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool ApplyRubyTextCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool ApplyRubyTextCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& ApplyRubyTextCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ApplyRubyTextCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyRubyTextCommandArchive.storage)
  return _internal_storage();
}
inline void ApplyRubyTextCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyRubyTextCommandArchive.storage)
}
inline ::TSP::Reference* ApplyRubyTextCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ApplyRubyTextCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyRubyTextCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ApplyRubyTextCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* ApplyRubyTextCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyRubyTextCommandArchive.storage)
  return _msg;
}
inline void ApplyRubyTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyRubyTextCommandArchive.storage)
}

// optional uint32 selection_range_location = 3;
inline bool ApplyRubyTextCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApplyRubyTextCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void ApplyRubyTextCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ApplyRubyTextCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t ApplyRubyTextCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyRubyTextCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void ApplyRubyTextCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_location_ = value;
}
inline void ApplyRubyTextCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.ApplyRubyTextCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 4;
inline bool ApplyRubyTextCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ApplyRubyTextCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void ApplyRubyTextCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ApplyRubyTextCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t ApplyRubyTextCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyRubyTextCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void ApplyRubyTextCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.selection_range_length_ = value;
}
inline void ApplyRubyTextCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.ApplyRubyTextCommandArchive.selection_range_length)
}

// optional string ruby_text = 5;
inline bool ApplyRubyTextCommandArchive::_internal_has_ruby_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplyRubyTextCommandArchive::has_ruby_text() const {
  return _internal_has_ruby_text();
}
inline void ApplyRubyTextCommandArchive::clear_ruby_text() {
  _impl_.ruby_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplyRubyTextCommandArchive::ruby_text() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyRubyTextCommandArchive.ruby_text)
  return _internal_ruby_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyRubyTextCommandArchive::set_ruby_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ruby_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.ApplyRubyTextCommandArchive.ruby_text)
}
inline std::string* ApplyRubyTextCommandArchive::mutable_ruby_text() {
  std::string* _s = _internal_mutable_ruby_text();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyRubyTextCommandArchive.ruby_text)
  return _s;
}
inline const std::string& ApplyRubyTextCommandArchive::_internal_ruby_text() const {
  return _impl_.ruby_text_.Get();
}
inline void ApplyRubyTextCommandArchive::_internal_set_ruby_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruby_text_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyRubyTextCommandArchive::_internal_mutable_ruby_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ruby_text_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyRubyTextCommandArchive::release_ruby_text() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyRubyTextCommandArchive.ruby_text)
  if (!_internal_has_ruby_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ruby_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ruby_text_.IsDefault()) {
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApplyRubyTextCommandArchive::set_allocated_ruby_text(std::string* ruby_text) {
  if (ruby_text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ruby_text_.SetAllocated(ruby_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ruby_text_.IsDefault()) {
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyRubyTextCommandArchive.ruby_text)
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool ApplyRubyTextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ApplyRubyTextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ApplyRubyTextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ApplyRubyTextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.ApplyRubyTextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ApplyRubyTextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ApplyRubyTextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ApplyRubyTextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ApplyRubyTextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.ApplyRubyTextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ApplyRubyTextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyRubyTextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.ApplyRubyTextCommandArchive.undo_transaction)
  return _msg;
}
inline void ApplyRubyTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ApplyRubyTextCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// RemoveRubyTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveRubyTextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool RemoveRubyTextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& RemoveRubyTextCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& RemoveRubyTextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRubyTextCommandArchive.super)
  return _internal_super();
}
inline void RemoveRubyTextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveRubyTextCommandArchive.super)
}
inline ::TSK::CommandArchive* RemoveRubyTextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* RemoveRubyTextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveRubyTextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* RemoveRubyTextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* RemoveRubyTextCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveRubyTextCommandArchive.super)
  return _msg;
}
inline void RemoveRubyTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveRubyTextCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool RemoveRubyTextCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool RemoveRubyTextCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& RemoveRubyTextCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveRubyTextCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRubyTextCommandArchive.storage)
  return _internal_storage();
}
inline void RemoveRubyTextCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveRubyTextCommandArchive.storage)
}
inline ::TSP::Reference* RemoveRubyTextCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveRubyTextCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveRubyTextCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveRubyTextCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* RemoveRubyTextCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveRubyTextCommandArchive.storage)
  return _msg;
}
inline void RemoveRubyTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveRubyTextCommandArchive.storage)
}

// optional uint32 selection_range_location = 3;
inline bool RemoveRubyTextCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoveRubyTextCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void RemoveRubyTextCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RemoveRubyTextCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t RemoveRubyTextCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRubyTextCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void RemoveRubyTextCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_range_location_ = value;
}
inline void RemoveRubyTextCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveRubyTextCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 4;
inline bool RemoveRubyTextCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RemoveRubyTextCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void RemoveRubyTextCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t RemoveRubyTextCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t RemoveRubyTextCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRubyTextCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void RemoveRubyTextCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_length_ = value;
}
inline void RemoveRubyTextCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TSWP.RemoveRubyTextCommandArchive.selection_range_length)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveRubyTextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool RemoveRubyTextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveRubyTextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& RemoveRubyTextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.RemoveRubyTextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void RemoveRubyTextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.RemoveRubyTextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* RemoveRubyTextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveRubyTextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.RemoveRubyTextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* RemoveRubyTextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveRubyTextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.RemoveRubyTextCommandArchive.undo_transaction)
  return _msg;
}
inline void RemoveRubyTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.RemoveRubyTextCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// ModifyRubyTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ModifyRubyTextCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ModifyRubyTextCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ModifyRubyTextCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ModifyRubyTextCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyRubyTextCommandArchive.super)
  return _internal_super();
}
inline void ModifyRubyTextCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyRubyTextCommandArchive.super)
}
inline ::TSK::CommandArchive* ModifyRubyTextCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ModifyRubyTextCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyRubyTextCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ModifyRubyTextCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ModifyRubyTextCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyRubyTextCommandArchive.super)
  return _msg;
}
inline void ModifyRubyTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyRubyTextCommandArchive.super)
}

// optional .TSP.Reference ruby_field = 2;
inline bool ModifyRubyTextCommandArchive::_internal_has_ruby_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ruby_field_ != nullptr);
  return value;
}
inline bool ModifyRubyTextCommandArchive::has_ruby_field() const {
  return _internal_has_ruby_field();
}
inline const ::TSP::Reference& ModifyRubyTextCommandArchive::_internal_ruby_field() const {
  const ::TSP::Reference* p = _impl_.ruby_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ModifyRubyTextCommandArchive::ruby_field() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyRubyTextCommandArchive.ruby_field)
  return _internal_ruby_field();
}
inline void ModifyRubyTextCommandArchive::unsafe_arena_set_allocated_ruby_field(
    ::TSP::Reference* ruby_field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ruby_field_);
  }
  _impl_.ruby_field_ = ruby_field;
  if (ruby_field) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyRubyTextCommandArchive.ruby_field)
}
inline ::TSP::Reference* ModifyRubyTextCommandArchive::release_ruby_field() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.ruby_field_;
  _impl_.ruby_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ModifyRubyTextCommandArchive::unsafe_arena_release_ruby_field() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyRubyTextCommandArchive.ruby_field)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.ruby_field_;
  _impl_.ruby_field_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ModifyRubyTextCommandArchive::_internal_mutable_ruby_field() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.ruby_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.ruby_field_ = p;
  }
  return _impl_.ruby_field_;
}
inline ::TSP::Reference* ModifyRubyTextCommandArchive::mutable_ruby_field() {
  ::TSP::Reference* _msg = _internal_mutable_ruby_field();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyRubyTextCommandArchive.ruby_field)
  return _msg;
}
inline void ModifyRubyTextCommandArchive::set_allocated_ruby_field(::TSP::Reference* ruby_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ruby_field_);
  }
  if (ruby_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ruby_field));
    if (message_arena != submessage_arena) {
      ruby_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ruby_field, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ruby_field_ = ruby_field;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyRubyTextCommandArchive.ruby_field)
}

// optional string ruby_text = 3;
inline bool ModifyRubyTextCommandArchive::_internal_has_ruby_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModifyRubyTextCommandArchive::has_ruby_text() const {
  return _internal_has_ruby_text();
}
inline void ModifyRubyTextCommandArchive::clear_ruby_text() {
  _impl_.ruby_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModifyRubyTextCommandArchive::ruby_text() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyRubyTextCommandArchive.ruby_text)
  return _internal_ruby_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyRubyTextCommandArchive::set_ruby_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ruby_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.ModifyRubyTextCommandArchive.ruby_text)
}
inline std::string* ModifyRubyTextCommandArchive::mutable_ruby_text() {
  std::string* _s = _internal_mutable_ruby_text();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyRubyTextCommandArchive.ruby_text)
  return _s;
}
inline const std::string& ModifyRubyTextCommandArchive::_internal_ruby_text() const {
  return _impl_.ruby_text_.Get();
}
inline void ModifyRubyTextCommandArchive::_internal_set_ruby_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ruby_text_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyRubyTextCommandArchive::_internal_mutable_ruby_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ruby_text_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyRubyTextCommandArchive::release_ruby_text() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyRubyTextCommandArchive.ruby_text)
  if (!_internal_has_ruby_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ruby_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ruby_text_.IsDefault()) {
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModifyRubyTextCommandArchive::set_allocated_ruby_text(std::string* ruby_text) {
  if (ruby_text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ruby_text_.SetAllocated(ruby_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ruby_text_.IsDefault()) {
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyRubyTextCommandArchive.ruby_text)
}

// optional string base_text = 4;
inline bool ModifyRubyTextCommandArchive::_internal_has_base_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModifyRubyTextCommandArchive::has_base_text() const {
  return _internal_has_base_text();
}
inline void ModifyRubyTextCommandArchive::clear_base_text() {
  _impl_.base_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModifyRubyTextCommandArchive::base_text() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyRubyTextCommandArchive.base_text)
  return _internal_base_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyRubyTextCommandArchive::set_base_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.base_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.ModifyRubyTextCommandArchive.base_text)
}
inline std::string* ModifyRubyTextCommandArchive::mutable_base_text() {
  std::string* _s = _internal_mutable_base_text();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyRubyTextCommandArchive.base_text)
  return _s;
}
inline const std::string& ModifyRubyTextCommandArchive::_internal_base_text() const {
  return _impl_.base_text_.Get();
}
inline void ModifyRubyTextCommandArchive::_internal_set_base_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.base_text_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyRubyTextCommandArchive::_internal_mutable_base_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.base_text_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyRubyTextCommandArchive::release_base_text() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyRubyTextCommandArchive.base_text)
  if (!_internal_has_base_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.base_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_text_.IsDefault()) {
    _impl_.base_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModifyRubyTextCommandArchive::set_allocated_base_text(std::string* base_text) {
  if (base_text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.base_text_.SetAllocated(base_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_text_.IsDefault()) {
    _impl_.base_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyRubyTextCommandArchive.base_text)
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ModifyRubyTextCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ModifyRubyTextCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ModifyRubyTextCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ModifyRubyTextCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyRubyTextCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ModifyRubyTextCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyRubyTextCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ModifyRubyTextCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ModifyRubyTextCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyRubyTextCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ModifyRubyTextCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ModifyRubyTextCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyRubyTextCommandArchive.undo_transaction)
  return _msg;
}
inline void ModifyRubyTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyRubyTextCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// ModifyTOCSettingsBaseCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ModifyTOCSettingsBaseCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ModifyTOCSettingsBaseCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ModifyTOCSettingsBaseCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ModifyTOCSettingsBaseCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsBaseCommandArchive.super)
  return _internal_super();
}
inline void ModifyTOCSettingsBaseCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyTOCSettingsBaseCommandArchive.super)
}
inline ::TSK::CommandArchive* ModifyTOCSettingsBaseCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ModifyTOCSettingsBaseCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyTOCSettingsBaseCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ModifyTOCSettingsBaseCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ModifyTOCSettingsBaseCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyTOCSettingsBaseCommandArchive.super)
  return _msg;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyTOCSettingsBaseCommandArchive.super)
}

// optional .TSP.Reference old_toc_settings = 2;
inline bool ModifyTOCSettingsBaseCommandArchive::_internal_has_old_toc_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.old_toc_settings_ != nullptr);
  return value;
}
inline bool ModifyTOCSettingsBaseCommandArchive::has_old_toc_settings() const {
  return _internal_has_old_toc_settings();
}
inline const ::TSP::Reference& ModifyTOCSettingsBaseCommandArchive::_internal_old_toc_settings() const {
  const ::TSP::Reference* p = _impl_.old_toc_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ModifyTOCSettingsBaseCommandArchive::old_toc_settings() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsBaseCommandArchive.old_toc_settings)
  return _internal_old_toc_settings();
}
inline void ModifyTOCSettingsBaseCommandArchive::unsafe_arena_set_allocated_old_toc_settings(
    ::TSP::Reference* old_toc_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_toc_settings_);
  }
  _impl_.old_toc_settings_ = old_toc_settings;
  if (old_toc_settings) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyTOCSettingsBaseCommandArchive.old_toc_settings)
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::release_old_toc_settings() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.old_toc_settings_;
  _impl_.old_toc_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::unsafe_arena_release_old_toc_settings() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyTOCSettingsBaseCommandArchive.old_toc_settings)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.old_toc_settings_;
  _impl_.old_toc_settings_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::_internal_mutable_old_toc_settings() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.old_toc_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.old_toc_settings_ = p;
  }
  return _impl_.old_toc_settings_;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::mutable_old_toc_settings() {
  ::TSP::Reference* _msg = _internal_mutable_old_toc_settings();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyTOCSettingsBaseCommandArchive.old_toc_settings)
  return _msg;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_allocated_old_toc_settings(::TSP::Reference* old_toc_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_toc_settings_);
  }
  if (old_toc_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_toc_settings));
    if (message_arena != submessage_arena) {
      old_toc_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_toc_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.old_toc_settings_ = old_toc_settings;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyTOCSettingsBaseCommandArchive.old_toc_settings)
}

// optional .TSP.Reference new_toc_settings = 3;
inline bool ModifyTOCSettingsBaseCommandArchive::_internal_has_new_toc_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.new_toc_settings_ != nullptr);
  return value;
}
inline bool ModifyTOCSettingsBaseCommandArchive::has_new_toc_settings() const {
  return _internal_has_new_toc_settings();
}
inline const ::TSP::Reference& ModifyTOCSettingsBaseCommandArchive::_internal_new_toc_settings() const {
  const ::TSP::Reference* p = _impl_.new_toc_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ModifyTOCSettingsBaseCommandArchive::new_toc_settings() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsBaseCommandArchive.new_toc_settings)
  return _internal_new_toc_settings();
}
inline void ModifyTOCSettingsBaseCommandArchive::unsafe_arena_set_allocated_new_toc_settings(
    ::TSP::Reference* new_toc_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_toc_settings_);
  }
  _impl_.new_toc_settings_ = new_toc_settings;
  if (new_toc_settings) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyTOCSettingsBaseCommandArchive.new_toc_settings)
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::release_new_toc_settings() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.new_toc_settings_;
  _impl_.new_toc_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::unsafe_arena_release_new_toc_settings() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyTOCSettingsBaseCommandArchive.new_toc_settings)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.new_toc_settings_;
  _impl_.new_toc_settings_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::_internal_mutable_new_toc_settings() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.new_toc_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.new_toc_settings_ = p;
  }
  return _impl_.new_toc_settings_;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::mutable_new_toc_settings() {
  ::TSP::Reference* _msg = _internal_mutable_new_toc_settings();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyTOCSettingsBaseCommandArchive.new_toc_settings)
  return _msg;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_allocated_new_toc_settings(::TSP::Reference* new_toc_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_toc_settings_);
  }
  if (new_toc_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_toc_settings));
    if (message_arena != submessage_arena) {
      new_toc_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_toc_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.new_toc_settings_ = new_toc_settings;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyTOCSettingsBaseCommandArchive.new_toc_settings)
}

// -------------------------------------------------------------------

// ModifyTOCSettingsForTOCInfoCommandArchive

// optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
inline bool ModifyTOCSettingsForTOCInfoCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ModifyTOCSettingsForTOCInfoCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& ModifyTOCSettingsForTOCInfoCommandArchive::_internal_super() const {
  const ::TSWP::ModifyTOCSettingsBaseCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::ModifyTOCSettingsBaseCommandArchive&>(
      ::TSWP::_ModifyTOCSettingsBaseCommandArchive_default_instance_);
}
inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& ModifyTOCSettingsForTOCInfoCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.super)
  return _internal_super();
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::ModifyTOCSettingsBaseCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.super)
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsForTOCInfoCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsForTOCInfoCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsForTOCInfoCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::ModifyTOCSettingsBaseCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsForTOCInfoCommandArchive::mutable_super() {
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.super)
  return _msg;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.super)
}

// optional .TSP.Reference toc_info = 2;
inline bool ModifyTOCSettingsForTOCInfoCommandArchive::_internal_has_toc_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.toc_info_ != nullptr);
  return value;
}
inline bool ModifyTOCSettingsForTOCInfoCommandArchive::has_toc_info() const {
  return _internal_has_toc_info();
}
inline const ::TSP::Reference& ModifyTOCSettingsForTOCInfoCommandArchive::_internal_toc_info() const {
  const ::TSP::Reference* p = _impl_.toc_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ModifyTOCSettingsForTOCInfoCommandArchive::toc_info() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.toc_info)
  return _internal_toc_info();
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::unsafe_arena_set_allocated_toc_info(
    ::TSP::Reference* toc_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.toc_info_);
  }
  _impl_.toc_info_ = toc_info;
  if (toc_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.toc_info)
}
inline ::TSP::Reference* ModifyTOCSettingsForTOCInfoCommandArchive::release_toc_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.toc_info_;
  _impl_.toc_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsForTOCInfoCommandArchive::unsafe_arena_release_toc_info() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.toc_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.toc_info_;
  _impl_.toc_info_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsForTOCInfoCommandArchive::_internal_mutable_toc_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.toc_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.toc_info_ = p;
  }
  return _impl_.toc_info_;
}
inline ::TSP::Reference* ModifyTOCSettingsForTOCInfoCommandArchive::mutable_toc_info() {
  ::TSP::Reference* _msg = _internal_mutable_toc_info();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.toc_info)
  return _msg;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::set_allocated_toc_info(::TSP::Reference* toc_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.toc_info_);
  }
  if (toc_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(toc_info));
    if (message_arena != submessage_arena) {
      toc_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, toc_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.toc_info_ = toc_info;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive.toc_info)
}

// -------------------------------------------------------------------

// ModifyTOCSettingsPresetForThemeCommandArchive

// optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& ModifyTOCSettingsPresetForThemeCommandArchive::_internal_super() const {
  const ::TSWP::ModifyTOCSettingsBaseCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::ModifyTOCSettingsBaseCommandArchive&>(
      ::TSWP::_ModifyTOCSettingsBaseCommandArchive_default_instance_);
}
inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& ModifyTOCSettingsPresetForThemeCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.super)
  return _internal_super();
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::ModifyTOCSettingsBaseCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.super)
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsPresetForThemeCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsPresetForThemeCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsPresetForThemeCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::ModifyTOCSettingsBaseCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsPresetForThemeCommandArchive::mutable_super() {
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.super)
  return _msg;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.super)
}

// optional .TSP.Reference theme = 2;
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::_internal_has_theme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.theme_ != nullptr);
  return value;
}
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::has_theme() const {
  return _internal_has_theme();
}
inline const ::TSP::Reference& ModifyTOCSettingsPresetForThemeCommandArchive::_internal_theme() const {
  const ::TSP::Reference* p = _impl_.theme_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ModifyTOCSettingsPresetForThemeCommandArchive::theme() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.theme)
  return _internal_theme();
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::unsafe_arena_set_allocated_theme(
    ::TSP::Reference* theme) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.theme_);
  }
  _impl_.theme_ = theme;
  if (theme) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.theme)
}
inline ::TSP::Reference* ModifyTOCSettingsPresetForThemeCommandArchive::release_theme() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsPresetForThemeCommandArchive::unsafe_arena_release_theme() {
  // @@protoc_insertion_point(field_release:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.theme)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ModifyTOCSettingsPresetForThemeCommandArchive::_internal_mutable_theme() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.theme_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.theme_ = p;
  }
  return _impl_.theme_;
}
inline ::TSP::Reference* ModifyTOCSettingsPresetForThemeCommandArchive::mutable_theme() {
  ::TSP::Reference* _msg = _internal_mutable_theme();
  // @@protoc_insertion_point(field_mutable:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.theme)
  return _msg;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_allocated_theme(::TSP::Reference* theme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.theme_);
  }
  if (theme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(theme));
    if (message_arena != submessage_arena) {
      theme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, theme, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.theme_ = theme;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.theme)
}

// optional uint32 preset_index = 3;
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::_internal_has_preset_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::has_preset_index() const {
  return _internal_has_preset_index();
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_preset_index() {
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ModifyTOCSettingsPresetForThemeCommandArchive::_internal_preset_index() const {
  return _impl_.preset_index_;
}
inline uint32_t ModifyTOCSettingsPresetForThemeCommandArchive::preset_index() const {
  // @@protoc_insertion_point(field_get:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.preset_index)
  return _internal_preset_index();
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::_internal_set_preset_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.preset_index_ = value;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_preset_index(uint32_t value) {
  _internal_set_preset_index(value);
  // @@protoc_insertion_point(field_set:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive.preset_index)
}

// -------------------------------------------------------------------

// AnchorAttachmentCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool AnchorAttachmentCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& AnchorAttachmentCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& AnchorAttachmentCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.super)
  return _internal_super();
}
inline void AnchorAttachmentCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.AnchorAttachmentCommandArchive.super)
}
inline ::TSK::CommandArchive* AnchorAttachmentCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* AnchorAttachmentCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.AnchorAttachmentCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* AnchorAttachmentCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* AnchorAttachmentCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.AnchorAttachmentCommandArchive.super)
  return _msg;
}
inline void AnchorAttachmentCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.AnchorAttachmentCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool AnchorAttachmentCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& AnchorAttachmentCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& AnchorAttachmentCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.storage)
  return _internal_storage();
}
inline void AnchorAttachmentCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.AnchorAttachmentCommandArchive.storage)
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.AnchorAttachmentCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.AnchorAttachmentCommandArchive.storage)
  return _msg;
}
inline void AnchorAttachmentCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.AnchorAttachmentCommandArchive.storage)
}

// optional .TSP.Reference attachment = 3;
inline bool AnchorAttachmentCommandArchive::_internal_has_attachment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attachment_ != nullptr);
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_attachment() const {
  return _internal_has_attachment();
}
inline const ::TSP::Reference& AnchorAttachmentCommandArchive::_internal_attachment() const {
  const ::TSP::Reference* p = _impl_.attachment_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& AnchorAttachmentCommandArchive::attachment() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.attachment)
  return _internal_attachment();
}
inline void AnchorAttachmentCommandArchive::unsafe_arena_set_allocated_attachment(
    ::TSP::Reference* attachment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  _impl_.attachment_ = attachment;
  if (attachment) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.AnchorAttachmentCommandArchive.attachment)
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::release_attachment() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::unsafe_arena_release_attachment() {
  // @@protoc_insertion_point(field_release:TSWP.AnchorAttachmentCommandArchive.attachment)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
  return temp;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::_internal_mutable_attachment() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.attachment_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.attachment_ = p;
  }
  return _impl_.attachment_;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::mutable_attachment() {
  ::TSP::Reference* _msg = _internal_mutable_attachment();
  // @@protoc_insertion_point(field_mutable:TSWP.AnchorAttachmentCommandArchive.attachment)
  return _msg;
}
inline void AnchorAttachmentCommandArchive::set_allocated_attachment(::TSP::Reference* attachment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  if (attachment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attachment));
    if (message_arena != submessage_arena) {
      attachment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attachment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attachment_ = attachment;
  // @@protoc_insertion_point(field_set_allocated:TSWP.AnchorAttachmentCommandArchive.attachment)
}

// optional uint32 h_offset_type = 4;
inline bool AnchorAttachmentCommandArchive::_internal_has_h_offset_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_h_offset_type() const {
  return _internal_has_h_offset_type();
}
inline void AnchorAttachmentCommandArchive::clear_h_offset_type() {
  _impl_.h_offset_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t AnchorAttachmentCommandArchive::_internal_h_offset_type() const {
  return _impl_.h_offset_type_;
}
inline uint32_t AnchorAttachmentCommandArchive::h_offset_type() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.h_offset_type)
  return _internal_h_offset_type();
}
inline void AnchorAttachmentCommandArchive::_internal_set_h_offset_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.h_offset_type_ = value;
}
inline void AnchorAttachmentCommandArchive::set_h_offset_type(uint32_t value) {
  _internal_set_h_offset_type(value);
  // @@protoc_insertion_point(field_set:TSWP.AnchorAttachmentCommandArchive.h_offset_type)
}

// optional float h_offset = 5;
inline bool AnchorAttachmentCommandArchive::_internal_has_h_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_h_offset() const {
  return _internal_has_h_offset();
}
inline void AnchorAttachmentCommandArchive::clear_h_offset() {
  _impl_.h_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float AnchorAttachmentCommandArchive::_internal_h_offset() const {
  return _impl_.h_offset_;
}
inline float AnchorAttachmentCommandArchive::h_offset() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.h_offset)
  return _internal_h_offset();
}
inline void AnchorAttachmentCommandArchive::_internal_set_h_offset(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.h_offset_ = value;
}
inline void AnchorAttachmentCommandArchive::set_h_offset(float value) {
  _internal_set_h_offset(value);
  // @@protoc_insertion_point(field_set:TSWP.AnchorAttachmentCommandArchive.h_offset)
}

// optional uint32 v_offset_type = 6;
inline bool AnchorAttachmentCommandArchive::_internal_has_v_offset_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_v_offset_type() const {
  return _internal_has_v_offset_type();
}
inline void AnchorAttachmentCommandArchive::clear_v_offset_type() {
  _impl_.v_offset_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t AnchorAttachmentCommandArchive::_internal_v_offset_type() const {
  return _impl_.v_offset_type_;
}
inline uint32_t AnchorAttachmentCommandArchive::v_offset_type() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.v_offset_type)
  return _internal_v_offset_type();
}
inline void AnchorAttachmentCommandArchive::_internal_set_v_offset_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.v_offset_type_ = value;
}
inline void AnchorAttachmentCommandArchive::set_v_offset_type(uint32_t value) {
  _internal_set_v_offset_type(value);
  // @@protoc_insertion_point(field_set:TSWP.AnchorAttachmentCommandArchive.v_offset_type)
}

// optional float v_offset = 7;
inline bool AnchorAttachmentCommandArchive::_internal_has_v_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_v_offset() const {
  return _internal_has_v_offset();
}
inline void AnchorAttachmentCommandArchive::clear_v_offset() {
  _impl_.v_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float AnchorAttachmentCommandArchive::_internal_v_offset() const {
  return _impl_.v_offset_;
}
inline float AnchorAttachmentCommandArchive::v_offset() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.v_offset)
  return _internal_v_offset();
}
inline void AnchorAttachmentCommandArchive::_internal_set_v_offset(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.v_offset_ = value;
}
inline void AnchorAttachmentCommandArchive::set_v_offset(float value) {
  _internal_set_v_offset(value);
  // @@protoc_insertion_point(field_set:TSWP.AnchorAttachmentCommandArchive.v_offset)
}

// optional .TSWP.UndoTransaction undo_transaction = 8;
inline bool AnchorAttachmentCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& AnchorAttachmentCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& AnchorAttachmentCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void AnchorAttachmentCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.AnchorAttachmentCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* AnchorAttachmentCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* AnchorAttachmentCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.AnchorAttachmentCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* AnchorAttachmentCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* AnchorAttachmentCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.AnchorAttachmentCommandArchive.undo_transaction)
  return _msg;
}
inline void AnchorAttachmentCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.AnchorAttachmentCommandArchive.undo_transaction)
}

// optional bool is_html_wrap = 9;
inline bool AnchorAttachmentCommandArchive::_internal_has_is_html_wrap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AnchorAttachmentCommandArchive::has_is_html_wrap() const {
  return _internal_has_is_html_wrap();
}
inline void AnchorAttachmentCommandArchive::clear_is_html_wrap() {
  _impl_.is_html_wrap_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool AnchorAttachmentCommandArchive::_internal_is_html_wrap() const {
  return _impl_.is_html_wrap_;
}
inline bool AnchorAttachmentCommandArchive::is_html_wrap() const {
  // @@protoc_insertion_point(field_get:TSWP.AnchorAttachmentCommandArchive.is_html_wrap)
  return _internal_is_html_wrap();
}
inline void AnchorAttachmentCommandArchive::_internal_set_is_html_wrap(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.is_html_wrap_ = value;
}
inline void AnchorAttachmentCommandArchive::set_is_html_wrap(bool value) {
  _internal_set_is_html_wrap(value);
  // @@protoc_insertion_point(field_set:TSWP.AnchorAttachmentCommandArchive.is_html_wrap)
}

// -------------------------------------------------------------------

// TextApplyThemeCommandArchive

// optional .TSS.ApplyThemeChildCommandArchive super = 1;
inline bool TextApplyThemeCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool TextApplyThemeCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::ApplyThemeChildCommandArchive& TextApplyThemeCommandArchive::_internal_super() const {
  const ::TSS::ApplyThemeChildCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::ApplyThemeChildCommandArchive&>(
      ::TSS::_ApplyThemeChildCommandArchive_default_instance_);
}
inline const ::TSS::ApplyThemeChildCommandArchive& TextApplyThemeCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.TextApplyThemeCommandArchive.super)
  return _internal_super();
}
inline void TextApplyThemeCommandArchive::unsafe_arena_set_allocated_super(
    ::TSS::ApplyThemeChildCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.TextApplyThemeCommandArchive.super)
}
inline ::TSS::ApplyThemeChildCommandArchive* TextApplyThemeCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::ApplyThemeChildCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::ApplyThemeChildCommandArchive* TextApplyThemeCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.TextApplyThemeCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::ApplyThemeChildCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::ApplyThemeChildCommandArchive* TextApplyThemeCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::ApplyThemeChildCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* TextApplyThemeCommandArchive::mutable_super() {
  ::TSS::ApplyThemeChildCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.TextApplyThemeCommandArchive.super)
  return _msg;
}
inline void TextApplyThemeCommandArchive::set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.TextApplyThemeCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool TextApplyThemeCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool TextApplyThemeCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& TextApplyThemeCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TextApplyThemeCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.TextApplyThemeCommandArchive.storage)
  return _internal_storage();
}
inline void TextApplyThemeCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.TextApplyThemeCommandArchive.storage)
}
inline ::TSP::Reference* TextApplyThemeCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TextApplyThemeCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.TextApplyThemeCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TextApplyThemeCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* TextApplyThemeCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.TextApplyThemeCommandArchive.storage)
  return _msg;
}
inline void TextApplyThemeCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.TextApplyThemeCommandArchive.storage)
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool TextApplyThemeCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool TextApplyThemeCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& TextApplyThemeCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& TextApplyThemeCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.TextApplyThemeCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void TextApplyThemeCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.TextApplyThemeCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* TextApplyThemeCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* TextApplyThemeCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.TextApplyThemeCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* TextApplyThemeCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* TextApplyThemeCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.TextApplyThemeCommandArchive.undo_transaction)
  return _msg;
}
inline void TextApplyThemeCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.TextApplyThemeCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// MoveColumnsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool MoveColumnsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveColumnsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveColumnsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveColumnsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveColumnsCommandArchive.super)
  return _internal_super();
}
inline void MoveColumnsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MoveColumnsCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveColumnsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveColumnsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.MoveColumnsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveColumnsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveColumnsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.MoveColumnsCommandArchive.super)
  return _msg;
}
inline void MoveColumnsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MoveColumnsCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool MoveColumnsCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool MoveColumnsCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& MoveColumnsCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveColumnsCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveColumnsCommandArchive.storage)
  return _internal_storage();
}
inline void MoveColumnsCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MoveColumnsCommandArchive.storage)
}
inline ::TSP::Reference* MoveColumnsCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveColumnsCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.MoveColumnsCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveColumnsCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* MoveColumnsCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.MoveColumnsCommandArchive.storage)
  return _msg;
}
inline void MoveColumnsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MoveColumnsCommandArchive.storage)
}

// optional uint32 src_index = 3;
inline bool MoveColumnsCommandArchive::_internal_has_src_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoveColumnsCommandArchive::has_src_index() const {
  return _internal_has_src_index();
}
inline void MoveColumnsCommandArchive::clear_src_index() {
  _impl_.src_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoveColumnsCommandArchive::_internal_src_index() const {
  return _impl_.src_index_;
}
inline uint32_t MoveColumnsCommandArchive::src_index() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveColumnsCommandArchive.src_index)
  return _internal_src_index();
}
inline void MoveColumnsCommandArchive::_internal_set_src_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.src_index_ = value;
}
inline void MoveColumnsCommandArchive::set_src_index(uint32_t value) {
  _internal_set_src_index(value);
  // @@protoc_insertion_point(field_set:TSWP.MoveColumnsCommandArchive.src_index)
}

// optional uint32 dst_index = 4;
inline bool MoveColumnsCommandArchive::_internal_has_dst_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoveColumnsCommandArchive::has_dst_index() const {
  return _internal_has_dst_index();
}
inline void MoveColumnsCommandArchive::clear_dst_index() {
  _impl_.dst_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoveColumnsCommandArchive::_internal_dst_index() const {
  return _impl_.dst_index_;
}
inline uint32_t MoveColumnsCommandArchive::dst_index() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveColumnsCommandArchive.dst_index)
  return _internal_dst_index();
}
inline void MoveColumnsCommandArchive::_internal_set_dst_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dst_index_ = value;
}
inline void MoveColumnsCommandArchive::set_dst_index(uint32_t value) {
  _internal_set_dst_index(value);
  // @@protoc_insertion_point(field_set:TSWP.MoveColumnsCommandArchive.dst_index)
}

// optional uint32 count = 5;
inline bool MoveColumnsCommandArchive::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoveColumnsCommandArchive::has_count() const {
  return _internal_has_count();
}
inline void MoveColumnsCommandArchive::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MoveColumnsCommandArchive::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t MoveColumnsCommandArchive::count() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveColumnsCommandArchive.count)
  return _internal_count();
}
inline void MoveColumnsCommandArchive::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.count_ = value;
}
inline void MoveColumnsCommandArchive::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TSWP.MoveColumnsCommandArchive.count)
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool MoveColumnsCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool MoveColumnsCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveColumnsCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& MoveColumnsCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveColumnsCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void MoveColumnsCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MoveColumnsCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* MoveColumnsCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* MoveColumnsCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.MoveColumnsCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* MoveColumnsCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveColumnsCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.MoveColumnsCommandArchive.undo_transaction)
  return _msg;
}
inline void MoveColumnsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MoveColumnsCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// MoveRowsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool MoveRowsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveRowsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveRowsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveRowsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveRowsCommandArchive.super)
  return _internal_super();
}
inline void MoveRowsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MoveRowsCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveRowsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveRowsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.MoveRowsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveRowsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveRowsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.MoveRowsCommandArchive.super)
  return _msg;
}
inline void MoveRowsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MoveRowsCommandArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool MoveRowsCommandArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool MoveRowsCommandArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& MoveRowsCommandArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveRowsCommandArchive::storage() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveRowsCommandArchive.storage)
  return _internal_storage();
}
inline void MoveRowsCommandArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MoveRowsCommandArchive.storage)
}
inline ::TSP::Reference* MoveRowsCommandArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveRowsCommandArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TSWP.MoveRowsCommandArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveRowsCommandArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* MoveRowsCommandArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TSWP.MoveRowsCommandArchive.storage)
  return _msg;
}
inline void MoveRowsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MoveRowsCommandArchive.storage)
}

// optional uint32 src_index = 3;
inline bool MoveRowsCommandArchive::_internal_has_src_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoveRowsCommandArchive::has_src_index() const {
  return _internal_has_src_index();
}
inline void MoveRowsCommandArchive::clear_src_index() {
  _impl_.src_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoveRowsCommandArchive::_internal_src_index() const {
  return _impl_.src_index_;
}
inline uint32_t MoveRowsCommandArchive::src_index() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveRowsCommandArchive.src_index)
  return _internal_src_index();
}
inline void MoveRowsCommandArchive::_internal_set_src_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.src_index_ = value;
}
inline void MoveRowsCommandArchive::set_src_index(uint32_t value) {
  _internal_set_src_index(value);
  // @@protoc_insertion_point(field_set:TSWP.MoveRowsCommandArchive.src_index)
}

// optional uint32 dst_index = 4;
inline bool MoveRowsCommandArchive::_internal_has_dst_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoveRowsCommandArchive::has_dst_index() const {
  return _internal_has_dst_index();
}
inline void MoveRowsCommandArchive::clear_dst_index() {
  _impl_.dst_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoveRowsCommandArchive::_internal_dst_index() const {
  return _impl_.dst_index_;
}
inline uint32_t MoveRowsCommandArchive::dst_index() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveRowsCommandArchive.dst_index)
  return _internal_dst_index();
}
inline void MoveRowsCommandArchive::_internal_set_dst_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dst_index_ = value;
}
inline void MoveRowsCommandArchive::set_dst_index(uint32_t value) {
  _internal_set_dst_index(value);
  // @@protoc_insertion_point(field_set:TSWP.MoveRowsCommandArchive.dst_index)
}

// optional uint32 count = 5;
inline bool MoveRowsCommandArchive::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoveRowsCommandArchive::has_count() const {
  return _internal_has_count();
}
inline void MoveRowsCommandArchive::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MoveRowsCommandArchive::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t MoveRowsCommandArchive::count() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveRowsCommandArchive.count)
  return _internal_count();
}
inline void MoveRowsCommandArchive::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.count_ = value;
}
inline void MoveRowsCommandArchive::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TSWP.MoveRowsCommandArchive.count)
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool MoveRowsCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool MoveRowsCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveRowsCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& MoveRowsCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TSWP.MoveRowsCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void MoveRowsCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.MoveRowsCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* MoveRowsCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* MoveRowsCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TSWP.MoveRowsCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* MoveRowsCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveRowsCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TSWP.MoveRowsCommandArchive.undo_transaction)
  return _msg;
}
inline void MoveRowsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TSWP.MoveRowsCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// ShapeApplyPresetCommandArchive

// required .TSD.ShapeApplyPresetCommandArchive super = 1;
inline bool ShapeApplyPresetCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ShapeApplyPresetCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSD::ShapeApplyPresetCommandArchive& ShapeApplyPresetCommandArchive::_internal_super() const {
  const ::TSD::ShapeApplyPresetCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShapeApplyPresetCommandArchive&>(
      ::TSD::_ShapeApplyPresetCommandArchive_default_instance_);
}
inline const ::TSD::ShapeApplyPresetCommandArchive& ShapeApplyPresetCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ShapeApplyPresetCommandArchive.super)
  return _internal_super();
}
inline void ShapeApplyPresetCommandArchive::unsafe_arena_set_allocated_super(
    ::TSD::ShapeApplyPresetCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ShapeApplyPresetCommandArchive.super)
}
inline ::TSD::ShapeApplyPresetCommandArchive* ShapeApplyPresetCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::ShapeApplyPresetCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ShapeApplyPresetCommandArchive* ShapeApplyPresetCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ShapeApplyPresetCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::ShapeApplyPresetCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::ShapeApplyPresetCommandArchive* ShapeApplyPresetCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShapeApplyPresetCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::ShapeApplyPresetCommandArchive* ShapeApplyPresetCommandArchive::mutable_super() {
  ::TSD::ShapeApplyPresetCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ShapeApplyPresetCommandArchive.super)
  return _msg;
}
inline void ShapeApplyPresetCommandArchive::set_allocated_super(::TSD::ShapeApplyPresetCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ShapeApplyPresetCommandArchive.super)
}

// -------------------------------------------------------------------

// ShapePasteStyleCommandArchive

// required .TSD.PasteStyleCommandArchive super = 1;
inline bool ShapePasteStyleCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ShapePasteStyleCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSD::PasteStyleCommandArchive& ShapePasteStyleCommandArchive::_internal_super() const {
  const ::TSD::PasteStyleCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PasteStyleCommandArchive&>(
      ::TSD::_PasteStyleCommandArchive_default_instance_);
}
inline const ::TSD::PasteStyleCommandArchive& ShapePasteStyleCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.ShapePasteStyleCommandArchive.super)
  return _internal_super();
}
inline void ShapePasteStyleCommandArchive::unsafe_arena_set_allocated_super(
    ::TSD::PasteStyleCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ShapePasteStyleCommandArchive.super)
}
inline ::TSD::PasteStyleCommandArchive* ShapePasteStyleCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::PasteStyleCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::PasteStyleCommandArchive* ShapePasteStyleCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.ShapePasteStyleCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::PasteStyleCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::PasteStyleCommandArchive* ShapePasteStyleCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PasteStyleCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::PasteStyleCommandArchive* ShapePasteStyleCommandArchive::mutable_super() {
  ::TSD::PasteStyleCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.ShapePasteStyleCommandArchive.super)
  return _msg;
}
inline void ShapePasteStyleCommandArchive::set_allocated_super(::TSD::PasteStyleCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ShapePasteStyleCommandArchive.super)
}

// optional .TSP.Reference paragraph_style = 2;
inline bool ShapePasteStyleCommandArchive::_internal_has_paragraph_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paragraph_style_ != nullptr);
  return value;
}
inline bool ShapePasteStyleCommandArchive::has_paragraph_style() const {
  return _internal_has_paragraph_style();
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::_internal_paragraph_style() const {
  const ::TSP::Reference* p = _impl_.paragraph_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::paragraph_style() const {
  // @@protoc_insertion_point(field_get:TSWP.ShapePasteStyleCommandArchive.paragraph_style)
  return _internal_paragraph_style();
}
inline void ShapePasteStyleCommandArchive::unsafe_arena_set_allocated_paragraph_style(
    ::TSP::Reference* paragraph_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paragraph_style_);
  }
  _impl_.paragraph_style_ = paragraph_style;
  if (paragraph_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ShapePasteStyleCommandArchive.paragraph_style)
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::release_paragraph_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.paragraph_style_;
  _impl_.paragraph_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::unsafe_arena_release_paragraph_style() {
  // @@protoc_insertion_point(field_release:TSWP.ShapePasteStyleCommandArchive.paragraph_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.paragraph_style_;
  _impl_.paragraph_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::_internal_mutable_paragraph_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.paragraph_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.paragraph_style_ = p;
  }
  return _impl_.paragraph_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::mutable_paragraph_style() {
  ::TSP::Reference* _msg = _internal_mutable_paragraph_style();
  // @@protoc_insertion_point(field_mutable:TSWP.ShapePasteStyleCommandArchive.paragraph_style)
  return _msg;
}
inline void ShapePasteStyleCommandArchive::set_allocated_paragraph_style(::TSP::Reference* paragraph_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paragraph_style_);
  }
  if (paragraph_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(paragraph_style));
    if (message_arena != submessage_arena) {
      paragraph_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paragraph_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.paragraph_style_ = paragraph_style;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ShapePasteStyleCommandArchive.paragraph_style)
}

// optional .TSP.Reference list_style = 3;
inline bool ShapePasteStyleCommandArchive::_internal_has_list_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.list_style_ != nullptr);
  return value;
}
inline bool ShapePasteStyleCommandArchive::has_list_style() const {
  return _internal_has_list_style();
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::_internal_list_style() const {
  const ::TSP::Reference* p = _impl_.list_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::list_style() const {
  // @@protoc_insertion_point(field_get:TSWP.ShapePasteStyleCommandArchive.list_style)
  return _internal_list_style();
}
inline void ShapePasteStyleCommandArchive::unsafe_arena_set_allocated_list_style(
    ::TSP::Reference* list_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_style_);
  }
  _impl_.list_style_ = list_style;
  if (list_style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ShapePasteStyleCommandArchive.list_style)
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::release_list_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.list_style_;
  _impl_.list_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::unsafe_arena_release_list_style() {
  // @@protoc_insertion_point(field_release:TSWP.ShapePasteStyleCommandArchive.list_style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.list_style_;
  _impl_.list_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::_internal_mutable_list_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.list_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.list_style_ = p;
  }
  return _impl_.list_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::mutable_list_style() {
  ::TSP::Reference* _msg = _internal_mutable_list_style();
  // @@protoc_insertion_point(field_mutable:TSWP.ShapePasteStyleCommandArchive.list_style)
  return _msg;
}
inline void ShapePasteStyleCommandArchive::set_allocated_list_style(::TSP::Reference* list_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_style_);
  }
  if (list_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(list_style));
    if (message_arena != submessage_arena) {
      list_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.list_style_ = list_style;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ShapePasteStyleCommandArchive.list_style)
}

// optional .TSP.Reference character_style = 4;
inline bool ShapePasteStyleCommandArchive::_internal_has_character_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_style_ != nullptr);
  return value;
}
inline bool ShapePasteStyleCommandArchive::has_character_style() const {
  return _internal_has_character_style();
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::_internal_character_style() const {
  const ::TSP::Reference* p = _impl_.character_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::character_style() const {
  // @@protoc_insertion_point(field_get:TSWP.ShapePasteStyleCommandArchive.character_style)
  return _internal_character_style();
}
inline void ShapePasteStyleCommandArchive::unsafe_arena_set_allocated_character_style(
    ::TSP::Reference* character_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.character_style_);
  }
  _impl_.character_style_ = character_style;
  if (character_style) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.ShapePasteStyleCommandArchive.character_style)
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::release_character_style() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.character_style_;
  _impl_.character_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::unsafe_arena_release_character_style() {
  // @@protoc_insertion_point(field_release:TSWP.ShapePasteStyleCommandArchive.character_style)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.character_style_;
  _impl_.character_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::_internal_mutable_character_style() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.character_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.character_style_ = p;
  }
  return _impl_.character_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::mutable_character_style() {
  ::TSP::Reference* _msg = _internal_mutable_character_style();
  // @@protoc_insertion_point(field_mutable:TSWP.ShapePasteStyleCommandArchive.character_style)
  return _msg;
}
inline void ShapePasteStyleCommandArchive::set_allocated_character_style(::TSP::Reference* character_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.character_style_);
  }
  if (character_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(character_style));
    if (message_arena != submessage_arena) {
      character_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, character_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.character_style_ = character_style;
  // @@protoc_insertion_point(field_set_allocated:TSWP.ShapePasteStyleCommandArchive.character_style)
}

// -------------------------------------------------------------------

// StyleBaseCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool StyleBaseCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StyleBaseCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& StyleBaseCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& StyleBaseCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleBaseCommandArchive.super)
  return _internal_super();
}
inline void StyleBaseCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleBaseCommandArchive.super)
}
inline ::TSK::CommandArchive* StyleBaseCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* StyleBaseCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.StyleBaseCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* StyleBaseCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* StyleBaseCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleBaseCommandArchive.super)
  return _msg;
}
inline void StyleBaseCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleBaseCommandArchive.super)
}

// optional .TSP.Reference theme = 2;
inline bool StyleBaseCommandArchive::_internal_has_theme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.theme_ != nullptr);
  return value;
}
inline bool StyleBaseCommandArchive::has_theme() const {
  return _internal_has_theme();
}
inline const ::TSP::Reference& StyleBaseCommandArchive::_internal_theme() const {
  const ::TSP::Reference* p = _impl_.theme_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& StyleBaseCommandArchive::theme() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleBaseCommandArchive.theme)
  return _internal_theme();
}
inline void StyleBaseCommandArchive::unsafe_arena_set_allocated_theme(
    ::TSP::Reference* theme) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.theme_);
  }
  _impl_.theme_ = theme;
  if (theme) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleBaseCommandArchive.theme)
}
inline ::TSP::Reference* StyleBaseCommandArchive::release_theme() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* StyleBaseCommandArchive::unsafe_arena_release_theme() {
  // @@protoc_insertion_point(field_release:TSWP.StyleBaseCommandArchive.theme)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
  return temp;
}
inline ::TSP::Reference* StyleBaseCommandArchive::_internal_mutable_theme() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.theme_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.theme_ = p;
  }
  return _impl_.theme_;
}
inline ::TSP::Reference* StyleBaseCommandArchive::mutable_theme() {
  ::TSP::Reference* _msg = _internal_mutable_theme();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleBaseCommandArchive.theme)
  return _msg;
}
inline void StyleBaseCommandArchive::set_allocated_theme(::TSP::Reference* theme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.theme_);
  }
  if (theme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(theme));
    if (message_arena != submessage_arena) {
      theme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, theme, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.theme_ = theme;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleBaseCommandArchive.theme)
}

// optional .TSP.Reference style = 3;
inline bool StyleBaseCommandArchive::_internal_has_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.style_ != nullptr);
  return value;
}
inline bool StyleBaseCommandArchive::has_style() const {
  return _internal_has_style();
}
inline const ::TSP::Reference& StyleBaseCommandArchive::_internal_style() const {
  const ::TSP::Reference* p = _impl_.style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& StyleBaseCommandArchive::style() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleBaseCommandArchive.style)
  return _internal_style();
}
inline void StyleBaseCommandArchive::unsafe_arena_set_allocated_style(
    ::TSP::Reference* style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  _impl_.style_ = style;
  if (style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleBaseCommandArchive.style)
}
inline ::TSP::Reference* StyleBaseCommandArchive::release_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* StyleBaseCommandArchive::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_release:TSWP.StyleBaseCommandArchive.style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* StyleBaseCommandArchive::_internal_mutable_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.style_ = p;
  }
  return _impl_.style_;
}
inline ::TSP::Reference* StyleBaseCommandArchive::mutable_style() {
  ::TSP::Reference* _msg = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleBaseCommandArchive.style)
  return _msg;
}
inline void StyleBaseCommandArchive::set_allocated_style(::TSP::Reference* style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  if (style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style));
    if (message_arena != submessage_arena) {
      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.style_ = style;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleBaseCommandArchive.style)
}

// -------------------------------------------------------------------

// StyleCreateCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleCreateCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StyleCreateCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void StyleCreateCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSWP::StyleBaseCommandArchive& StyleCreateCommandArchive::_internal_super() const {
  const ::TSWP::StyleBaseCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::StyleBaseCommandArchive&>(
      ::TSWP::_StyleBaseCommandArchive_default_instance_);
}
inline const ::TSWP::StyleBaseCommandArchive& StyleCreateCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleCreateCommandArchive.super)
  return _internal_super();
}
inline void StyleCreateCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::StyleBaseCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleCreateCommandArchive.super)
}
inline ::TSWP::StyleBaseCommandArchive* StyleCreateCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleCreateCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.StyleCreateCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleCreateCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::StyleBaseCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleCreateCommandArchive::mutable_super() {
  ::TSWP::StyleBaseCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleCreateCommandArchive.super)
  return _msg;
}
inline void StyleCreateCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleCreateCommandArchive.super)
}

// optional uint32 preset_index = 2;
inline bool StyleCreateCommandArchive::_internal_has_preset_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StyleCreateCommandArchive::has_preset_index() const {
  return _internal_has_preset_index();
}
inline void StyleCreateCommandArchive::clear_preset_index() {
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StyleCreateCommandArchive::_internal_preset_index() const {
  return _impl_.preset_index_;
}
inline uint32_t StyleCreateCommandArchive::preset_index() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleCreateCommandArchive.preset_index)
  return _internal_preset_index();
}
inline void StyleCreateCommandArchive::_internal_set_preset_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.preset_index_ = value;
}
inline void StyleCreateCommandArchive::set_preset_index(uint32_t value) {
  _internal_set_preset_index(value);
  // @@protoc_insertion_point(field_set:TSWP.StyleCreateCommandArchive.preset_index)
}

// -------------------------------------------------------------------

// StyleRenameCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleRenameCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StyleRenameCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void StyleRenameCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSWP::StyleBaseCommandArchive& StyleRenameCommandArchive::_internal_super() const {
  const ::TSWP::StyleBaseCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::StyleBaseCommandArchive&>(
      ::TSWP::_StyleBaseCommandArchive_default_instance_);
}
inline const ::TSWP::StyleBaseCommandArchive& StyleRenameCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleRenameCommandArchive.super)
  return _internal_super();
}
inline void StyleRenameCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::StyleBaseCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleRenameCommandArchive.super)
}
inline ::TSWP::StyleBaseCommandArchive* StyleRenameCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleRenameCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.StyleRenameCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleRenameCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::StyleBaseCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleRenameCommandArchive::mutable_super() {
  ::TSWP::StyleBaseCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleRenameCommandArchive.super)
  return _msg;
}
inline void StyleRenameCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleRenameCommandArchive.super)
}

// optional string updated_name = 2;
inline bool StyleRenameCommandArchive::_internal_has_updated_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StyleRenameCommandArchive::has_updated_name() const {
  return _internal_has_updated_name();
}
inline void StyleRenameCommandArchive::clear_updated_name() {
  _impl_.updated_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StyleRenameCommandArchive::updated_name() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleRenameCommandArchive.updated_name)
  return _internal_updated_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StyleRenameCommandArchive::set_updated_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.updated_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.StyleRenameCommandArchive.updated_name)
}
inline std::string* StyleRenameCommandArchive::mutable_updated_name() {
  std::string* _s = _internal_mutable_updated_name();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleRenameCommandArchive.updated_name)
  return _s;
}
inline const std::string& StyleRenameCommandArchive::_internal_updated_name() const {
  return _impl_.updated_name_.Get();
}
inline void StyleRenameCommandArchive::_internal_set_updated_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.updated_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StyleRenameCommandArchive::_internal_mutable_updated_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.updated_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StyleRenameCommandArchive::release_updated_name() {
  // @@protoc_insertion_point(field_release:TSWP.StyleRenameCommandArchive.updated_name)
  if (!_internal_has_updated_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.updated_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updated_name_.IsDefault()) {
    _impl_.updated_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StyleRenameCommandArchive::set_allocated_updated_name(std::string* updated_name) {
  if (updated_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.updated_name_.SetAllocated(updated_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updated_name_.IsDefault()) {
    _impl_.updated_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleRenameCommandArchive.updated_name)
}

// optional string old_name = 3;
inline bool StyleRenameCommandArchive::_internal_has_old_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StyleRenameCommandArchive::has_old_name() const {
  return _internal_has_old_name();
}
inline void StyleRenameCommandArchive::clear_old_name() {
  _impl_.old_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StyleRenameCommandArchive::old_name() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleRenameCommandArchive.old_name)
  return _internal_old_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StyleRenameCommandArchive::set_old_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.old_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSWP.StyleRenameCommandArchive.old_name)
}
inline std::string* StyleRenameCommandArchive::mutable_old_name() {
  std::string* _s = _internal_mutable_old_name();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleRenameCommandArchive.old_name)
  return _s;
}
inline const std::string& StyleRenameCommandArchive::_internal_old_name() const {
  return _impl_.old_name_.Get();
}
inline void StyleRenameCommandArchive::_internal_set_old_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.old_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StyleRenameCommandArchive::_internal_mutable_old_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.old_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StyleRenameCommandArchive::release_old_name() {
  // @@protoc_insertion_point(field_release:TSWP.StyleRenameCommandArchive.old_name)
  if (!_internal_has_old_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.old_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_name_.IsDefault()) {
    _impl_.old_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StyleRenameCommandArchive::set_allocated_old_name(std::string* old_name) {
  if (old_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.old_name_.SetAllocated(old_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_name_.IsDefault()) {
    _impl_.old_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleRenameCommandArchive.old_name)
}

// -------------------------------------------------------------------

// StyleUpdateCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleUpdateCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StyleUpdateCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void StyleUpdateCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSWP::StyleBaseCommandArchive& StyleUpdateCommandArchive::_internal_super() const {
  const ::TSWP::StyleBaseCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::StyleBaseCommandArchive&>(
      ::TSWP::_StyleBaseCommandArchive_default_instance_);
}
inline const ::TSWP::StyleBaseCommandArchive& StyleUpdateCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleUpdateCommandArchive.super)
  return _internal_super();
}
inline void StyleUpdateCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::StyleBaseCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleUpdateCommandArchive.super)
}
inline ::TSWP::StyleBaseCommandArchive* StyleUpdateCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleUpdateCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.StyleUpdateCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleUpdateCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::StyleBaseCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleUpdateCommandArchive::mutable_super() {
  ::TSWP::StyleBaseCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleUpdateCommandArchive.super)
  return _msg;
}
inline void StyleUpdateCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleUpdateCommandArchive.super)
}

// optional .TSP.Reference original_style = 2;
inline bool StyleUpdateCommandArchive::_internal_has_original_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.original_style_ != nullptr);
  return value;
}
inline bool StyleUpdateCommandArchive::has_original_style() const {
  return _internal_has_original_style();
}
inline const ::TSP::Reference& StyleUpdateCommandArchive::_internal_original_style() const {
  const ::TSP::Reference* p = _impl_.original_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& StyleUpdateCommandArchive::original_style() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleUpdateCommandArchive.original_style)
  return _internal_original_style();
}
inline void StyleUpdateCommandArchive::unsafe_arena_set_allocated_original_style(
    ::TSP::Reference* original_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.original_style_);
  }
  _impl_.original_style_ = original_style;
  if (original_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleUpdateCommandArchive.original_style)
}
inline ::TSP::Reference* StyleUpdateCommandArchive::release_original_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.original_style_;
  _impl_.original_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::unsafe_arena_release_original_style() {
  // @@protoc_insertion_point(field_release:TSWP.StyleUpdateCommandArchive.original_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.original_style_;
  _impl_.original_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::_internal_mutable_original_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.original_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.original_style_ = p;
  }
  return _impl_.original_style_;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::mutable_original_style() {
  ::TSP::Reference* _msg = _internal_mutable_original_style();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleUpdateCommandArchive.original_style)
  return _msg;
}
inline void StyleUpdateCommandArchive::set_allocated_original_style(::TSP::Reference* original_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.original_style_);
  }
  if (original_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(original_style));
    if (message_arena != submessage_arena) {
      original_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, original_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.original_style_ = original_style;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleUpdateCommandArchive.original_style)
}

// optional .TSP.Reference updated_style = 3;
inline bool StyleUpdateCommandArchive::_internal_has_updated_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_style_ != nullptr);
  return value;
}
inline bool StyleUpdateCommandArchive::has_updated_style() const {
  return _internal_has_updated_style();
}
inline const ::TSP::Reference& StyleUpdateCommandArchive::_internal_updated_style() const {
  const ::TSP::Reference* p = _impl_.updated_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& StyleUpdateCommandArchive::updated_style() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleUpdateCommandArchive.updated_style)
  return _internal_updated_style();
}
inline void StyleUpdateCommandArchive::unsafe_arena_set_allocated_updated_style(
    ::TSP::Reference* updated_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_style_);
  }
  _impl_.updated_style_ = updated_style;
  if (updated_style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleUpdateCommandArchive.updated_style)
}
inline ::TSP::Reference* StyleUpdateCommandArchive::release_updated_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.updated_style_;
  _impl_.updated_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::unsafe_arena_release_updated_style() {
  // @@protoc_insertion_point(field_release:TSWP.StyleUpdateCommandArchive.updated_style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.updated_style_;
  _impl_.updated_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::_internal_mutable_updated_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.updated_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.updated_style_ = p;
  }
  return _impl_.updated_style_;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::mutable_updated_style() {
  ::TSP::Reference* _msg = _internal_mutable_updated_style();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleUpdateCommandArchive.updated_style)
  return _msg;
}
inline void StyleUpdateCommandArchive::set_allocated_updated_style(::TSP::Reference* updated_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_style_);
  }
  if (updated_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_style));
    if (message_arena != submessage_arena) {
      updated_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.updated_style_ = updated_style;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleUpdateCommandArchive.updated_style)
}

// -------------------------------------------------------------------

// StyleDeleteCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleDeleteCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StyleDeleteCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void StyleDeleteCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSWP::StyleBaseCommandArchive& StyleDeleteCommandArchive::_internal_super() const {
  const ::TSWP::StyleBaseCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::StyleBaseCommandArchive&>(
      ::TSWP::_StyleBaseCommandArchive_default_instance_);
}
inline const ::TSWP::StyleBaseCommandArchive& StyleDeleteCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleDeleteCommandArchive.super)
  return _internal_super();
}
inline void StyleDeleteCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::StyleBaseCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleDeleteCommandArchive.super)
}
inline ::TSWP::StyleBaseCommandArchive* StyleDeleteCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleDeleteCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.StyleDeleteCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleDeleteCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::StyleBaseCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleDeleteCommandArchive::mutable_super() {
  ::TSWP::StyleBaseCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleDeleteCommandArchive.super)
  return _msg;
}
inline void StyleDeleteCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleDeleteCommandArchive.super)
}

// optional uint32 old_preset_index = 2;
inline bool StyleDeleteCommandArchive::_internal_has_old_preset_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StyleDeleteCommandArchive::has_old_preset_index() const {
  return _internal_has_old_preset_index();
}
inline void StyleDeleteCommandArchive::clear_old_preset_index() {
  _impl_.old_preset_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StyleDeleteCommandArchive::_internal_old_preset_index() const {
  return _impl_.old_preset_index_;
}
inline uint32_t StyleDeleteCommandArchive::old_preset_index() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleDeleteCommandArchive.old_preset_index)
  return _internal_old_preset_index();
}
inline void StyleDeleteCommandArchive::_internal_set_old_preset_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.old_preset_index_ = value;
}
inline void StyleDeleteCommandArchive::set_old_preset_index(uint32_t value) {
  _internal_set_old_preset_index(value);
  // @@protoc_insertion_point(field_set:TSWP.StyleDeleteCommandArchive.old_preset_index)
}

// -------------------------------------------------------------------

// StyleReorderCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleReorderCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StyleReorderCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void StyleReorderCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSWP::StyleBaseCommandArchive& StyleReorderCommandArchive::_internal_super() const {
  const ::TSWP::StyleBaseCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::StyleBaseCommandArchive&>(
      ::TSWP::_StyleBaseCommandArchive_default_instance_);
}
inline const ::TSWP::StyleBaseCommandArchive& StyleReorderCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleReorderCommandArchive.super)
  return _internal_super();
}
inline void StyleReorderCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::StyleBaseCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleReorderCommandArchive.super)
}
inline ::TSWP::StyleBaseCommandArchive* StyleReorderCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleReorderCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.StyleReorderCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::StyleBaseCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::StyleBaseCommandArchive* StyleReorderCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::StyleBaseCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleReorderCommandArchive::mutable_super() {
  ::TSWP::StyleBaseCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleReorderCommandArchive.super)
  return _msg;
}
inline void StyleReorderCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleReorderCommandArchive.super)
}

// optional uint32 old_preset_index = 2;
inline bool StyleReorderCommandArchive::_internal_has_old_preset_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StyleReorderCommandArchive::has_old_preset_index() const {
  return _internal_has_old_preset_index();
}
inline void StyleReorderCommandArchive::clear_old_preset_index() {
  _impl_.old_preset_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StyleReorderCommandArchive::_internal_old_preset_index() const {
  return _impl_.old_preset_index_;
}
inline uint32_t StyleReorderCommandArchive::old_preset_index() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleReorderCommandArchive.old_preset_index)
  return _internal_old_preset_index();
}
inline void StyleReorderCommandArchive::_internal_set_old_preset_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.old_preset_index_ = value;
}
inline void StyleReorderCommandArchive::set_old_preset_index(uint32_t value) {
  _internal_set_old_preset_index(value);
  // @@protoc_insertion_point(field_set:TSWP.StyleReorderCommandArchive.old_preset_index)
}

// optional uint32 new_preset_index = 3;
inline bool StyleReorderCommandArchive::_internal_has_new_preset_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StyleReorderCommandArchive::has_new_preset_index() const {
  return _internal_has_new_preset_index();
}
inline void StyleReorderCommandArchive::clear_new_preset_index() {
  _impl_.new_preset_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StyleReorderCommandArchive::_internal_new_preset_index() const {
  return _impl_.new_preset_index_;
}
inline uint32_t StyleReorderCommandArchive::new_preset_index() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleReorderCommandArchive.new_preset_index)
  return _internal_new_preset_index();
}
inline void StyleReorderCommandArchive::_internal_set_new_preset_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.new_preset_index_ = value;
}
inline void StyleReorderCommandArchive::set_new_preset_index(uint32_t value) {
  _internal_set_new_preset_index(value);
  // @@protoc_insertion_point(field_set:TSWP.StyleReorderCommandArchive.new_preset_index)
}

// -------------------------------------------------------------------

// StyleUpdatePropertyMapCommandArchive

// required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
inline bool StyleUpdatePropertyMapCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StyleUpdatePropertyMapCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleUpdatePropertyMapCommandArchive& StyleUpdatePropertyMapCommandArchive::_internal_super() const {
  const ::TSS::StyleUpdatePropertyMapCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleUpdatePropertyMapCommandArchive&>(
      ::TSS::_StyleUpdatePropertyMapCommandArchive_default_instance_);
}
inline const ::TSS::StyleUpdatePropertyMapCommandArchive& StyleUpdatePropertyMapCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSWP.StyleUpdatePropertyMapCommandArchive.super)
  return _internal_super();
}
inline void StyleUpdatePropertyMapCommandArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleUpdatePropertyMapCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSWP.StyleUpdatePropertyMapCommandArchive.super)
}
inline ::TSS::StyleUpdatePropertyMapCommandArchive* StyleUpdatePropertyMapCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleUpdatePropertyMapCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleUpdatePropertyMapCommandArchive* StyleUpdatePropertyMapCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSWP.StyleUpdatePropertyMapCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleUpdatePropertyMapCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleUpdatePropertyMapCommandArchive* StyleUpdatePropertyMapCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleUpdatePropertyMapCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleUpdatePropertyMapCommandArchive* StyleUpdatePropertyMapCommandArchive::mutable_super() {
  ::TSS::StyleUpdatePropertyMapCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSWP.StyleUpdatePropertyMapCommandArchive.super)
  return _msg;
}
inline void StyleUpdatePropertyMapCommandArchive::set_allocated_super(::TSS::StyleUpdatePropertyMapCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSWP.StyleUpdatePropertyMapCommandArchive.super)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSWP

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TSWP::TextCommandArchive_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::TextCommandArchive_Kind>() {
  return ::TSWP::TextCommandArchive_Kind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSWPCommandArchives_2eproto
